//go:build checkmk_all || checkmk_v2_2_0

// Code generated by openapi-gen from CheckMK 1.0. DO NOT EDIT.
//
// Field metadata including descriptions and types
//
// Source: metadata.gen.go
// Schemas: All (unfiltered)

package p5

// FieldDescriptions maps schema names to field descriptions.
// Use for generating documentation or user-facing error messages.
var FieldDescriptions = map[string]map[string]string{
	"AcknowledgeHostGroupProblem": {
		"acknowledge_type": "The acknowledge host selection type.",
		"comment": "If set, this comment will be stored alongside the acknowledgement.",
		"hostgroup_name": "The name of the host group.",
		"notify": "If set, notifications will be sent out to the configured contacts. Defaults to False.",
		"persistent": "If set, the comment will persist a restart. Defaults to False.",
		"sticky": "If set, only a state-change of the host to an UP state will discard the acknowledgement. Otherwise it will be discarded on any state-change. Defaults to False.",
	},
	"AcknowledgeHostProblem": {
		"acknowledge_type": "The acknowledge host selection type.",
		"comment": "If set, this comment will be stored alongside the acknowledgement.",
		"host_name": "The name of the host.",
		"notify": "If set, notifications will be sent out to the configured contacts. Defaults to False.",
		"persistent": "If set, the comment will persist a restart. Defaults to False.",
		"sticky": "If set, only a state-change of the host to an UP state will discard the acknowledgement. Otherwise it will be discarded on any state-change. Defaults to False.",
	},
	"AcknowledgeHostQueryProblem": {
		"acknowledge_type": "The acknowledge host selection type.",
		"comment": "If set, this comment will be stored alongside the acknowledgement.",
		"notify": "If set, notifications will be sent out to the configured contacts. Defaults to False.",
		"persistent": "If set, the comment will persist a restart. Defaults to False.",
		"query": "An query expression of the Livestatus 'hosts' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
		"sticky": "If set, only a state-change of the host to an UP state will discard the acknowledgement. Otherwise it will be discarded on any state-change. Defaults to False.",
	},
	"AcknowledgeServiceGroupProblem": {
		"acknowledge_type": "The acknowledge service selection type.",
		"comment": "If set, this comment will be stored alongside the acknowledgement.",
		"notify": "If set, notifications will be sent out to the configured contacts. Defaults to False.",
		"persistent": "If set, the comment will persist a restart. Defaults to False.",
		"servicegroup_name": "The name of the service group. Any host having a service in this group will be A downtime will be scheduled for all hosts in this group.",
		"sticky": "If set, only a state-change of the service to an OK state will discard the acknowledgement. Otherwise, it will be discarded on any state-change. Defaults to False.",
	},
	"AcknowledgeServiceQueryProblem": {
		"acknowledge_type": "The acknowledge service selection type.",
		"comment": "If set, this comment will be stored alongside the acknowledgement.",
		"notify": "If set, notifications will be sent out to the configured contacts. Defaults to False.",
		"persistent": "If set, the comment will persist a restart. Defaults to False.",
		"query": "An query expression of the Livestatus 'services' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
		"sticky": "If set, only a state-change of the service to an OK state will discard the acknowledgement. Otherwise, it will be discarded on any state-change. Defaults to False.",
	},
	"AcknowledgeSpecificServiceProblem": {
		"acknowledge_type": "The acknowledge service selection type.",
		"comment": "If set, this comment will be stored alongside the acknowledgement.",
		"notify": "If set, notifications will be sent out to the configured contacts. Defaults to False.",
		"persistent": "If set, the comment will persist a restart. Defaults to False.",
		"service_description": "The acknowledgement process will be applied to all matching service descriptions",
		"sticky": "If set, only a state-change of the service to an OK state will discard the acknowledgement. Otherwise, it will be discarded on any state-change. Defaults to False.",
	},
	"ActivateChanges": {
		"force_foreign_changes": "Will activate changes even if the user who made those changes is not the currently logged in user.",
		"redirect": "After starting the activation, redirect immediately to the 'Wait for completion' endpoint instead of waiting for the completion.",
		"sites": "The names of the sites on which the configuration shall be activated. An empty list means all sites which have pending changes.",
	},
	"ActivationExtensionFields": {
		"changes": "The changes in this activation",
		"force_foreign_changes": "If the activation is still running",
		"is_running": "If the activation is still running",
		"sites": "Sites affected by this activation",
		"time_started": "The date and time the activation was started.",
	},
	"ActivationRunCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"value": "A list of activation runs.",
	},
	"ActivationRunResponse": {
		"domainType": "The domain type of the object.",
		"extensions": "The activation run attributes.",
		"id": "The unique identifier for this activation run.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "The activation run status.",
	},
	"AgentControllerCertificateSettings": {
		"lifetime_in_months": "Lifetime of agent controller certificates in months",
	},
	"ApiError": {
		"detail": "Detailed information on what exactly went wrong.",
		"ext": "Additional information about the error.",
		"fields": "Detailed error messages on all fields failing validation.",
		"status": "The HTTP status code.",
		"title": "A summary of the problem.",
	},
	"AsciiMailPluginCreate": {
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"AuthOption1": {
		"enforce_password_change": "If set to True, the user will be forced to change his password on the next login or access. Defaults to False",
	},
	"AuthPassword": {
		"auth_type": "The authentication type",
		"enforce_password_change": "If set to True, the user will be forced to change his password on the next login or access. Defaults to False",
		"password": "The password for login",
	},
	"AuthSecret": {
		"auth_type": "The authentication type",
		"secret": "For accounts used by automation processes (such as fetching data from views for further procession). This is the automation secret",
	},
	"AuthUpdatePassword": {
		"auth_type": "The authentication type",
		"enforce_password_change": "If set to True, the user will be forced to change his password on the next login or access",
		"password": "The password for login",
	},
	"AuthUpdateRemove": {
		"auth_type": "The authentication type",
	},
	"AuthUpdateSecret": {
		"auth_type": "The authentication type",
		"secret": "For accounts used by automation processes (such as fetching data from views for further procession). This is the automation secret",
	},
	"AuxTagAttrsCreate": {
		"aux_tag_id": "An auxiliary tag id",
		"help": "The help of the Auxiliary tag",
		"title": "The title of the Auxiliary tag",
		"topic": "Different tags can be grouped in topics to make the visualization and selections in the GUI more comfortable",
	},
	"AuxTagAttrsResponse": {
		"help": "The help of the Auxiliary tag",
		"topic": "Different tags can be grouped in topics to make the visualization and selections in the GUI more comfortable",
	},
	"AuxTagAttrsUpdate": {
		"help": "The help of the Auxiliary tag",
		"title": "The title of the Auxiliary tag",
		"topic": "Different tags can be grouped in topics to make the visualization and selections in the GUI more comfortable",
	},
	"AuxTagResponse": {
		"domainType": "The domain type of the object.",
		"extensions": "The Auxiliary Tag attributes.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"AuxTagResponseCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of site configuration objects.",
	},
	"BIAggregationEndpoint": {
		"aggregation_visualization": "Nested dictionary",
		"comment": "An optional comment that may be used to explain the purpose of this object.",
		"computation_options": "Nested dictionary",
		"customer": "CME Edition only: The customer id for this aggregation.",
		"groups": "Nested dictionary",
		"id": "The unique aggregation id",
		"node": "Nested dictionary",
		"pack_id": "The identifier of the BI pack.",
	},
	"BIAggregationStateRequest": {
		"filter_groups": "Filter by group",
		"filter_names": "Filter by names",
	},
	"BIAggregationStateResponse": {
		"aggregations": "The Aggregation state",
		"missing_aggr": "the missing aggregations",
		"missing_sites": "The missing sites",
	},
	"BINodeGenerator": {
		"action": "Nested dictionary",
		"search": "Nested dictionary",
	},
	"BIPackEndpoint": {
		"contact_groups": "A list of contact group identifiers.",
		"public": "Should the BI pack be public or not.",
		"title": "The title of the BI pack.",
	},
	"BIRuleEndpoint": {
		"aggregation_function": "Nested dictionary",
		"computation_options": "Nested dictionary",
		"id": "The unique rule id",
		"node_visualization": "Nested dictionary",
		"nodes": "A list of nodes for for this rule",
		"pack_id": "The identifier of the BI pack.",
		"params": "Nested dictionary",
		"properties": "Nested dictionary",
	},
	"BackgroundJobStatus": {
		"active": "This field indicates if the background job is active or not.",
		"logs": "Logs related to the background job.",
		"state": "This field indicates the current state of the background job.",
	},
	"BaseUserAttributes": {
		"auth_option": "Enforce password change attribute for the user",
		"authorized_sites": "The names of the sites that this user is authorized to handle",
		"contact_options": "Contact settings for the user",
		"contactgroups": "The contact groups that this user is a member of",
		"disable_login": "This field indicates if the user is allowed to login to the monitoring.",
		"fullname": "The alias or full name of the user.",
		"idle_timeout": "Idle timeout for the user. Per default, the global configuration is used.",
		"language": "The language used by the user in the user interface",
		"roles": "The list of assigned roles to the user",
		"temperature_unit": "The temperature unit used for graphs and perfometers.",
	},
	"BasicSettingsAttributes": {
		"alias": "The alias of the site.",
		"site_id": "The site id.",
	},
	"BasicSettingsAttributesCreate": {
		"alias": "The alias of the site.",
		"site_id": "The site ID.",
	},
	"BasicSettingsAttributesUpdate": {
		"alias": "The alias of the site.",
		"site_id": "The site ID.",
	},
	"BinaryExpr": {
		"left": "The LiveStatus column name.",
		"op": "The operator.",
		"right": "The value to compare the column to.",
	},
	"BulkCreateHost": {
		"entries": "A list of host entries.",
	},
	"BulkDeleteContactGroup": {
		"entries": "A list of contract group names.",
	},
	"BulkDeleteHost": {
		"entries": "A list of host names.",
	},
	"BulkDeleteHostGroup": {
		"entries": "A list of host group names.",
	},
	"BulkDeleteServiceGroup": {
		"entries": "A list of service group names.",
	},
	"BulkDiscovery": {
		"bulk_size": "The number of hosts to be handled at once.",
		"do_full_scan": "The option whether to perform a full scan or not.",
		"hostnames": "A list of host names",
		"ignore_errors": "The option whether to ignore errors in single check plugins.",
		"mode": "The mode of the discovery action. The 'refresh' mode starts a new service discovery which will contact the host and identify undecided and vanished services and host labels. Those services and host labels can be added or removed accordingly with the 'fix_all' mode. The 'tabula_rasa' mode combines...",
	},
	"BulkHostActionWithFailedHosts": {
		"detail": "Detailed information on what exactly went wrong.",
		"ext": "Details for which hosts have failed",
		"fields": "Detailed error messages on all fields failing validation.",
		"status": "The HTTP status code.",
		"title": "A summary of the problem.",
	},
	"BulkInputContactGroup": {
		"entries": "A collection of contact group entries.",
	},
	"BulkInputHostGroup": {
		"entries": "A list of host group entries.",
	},
	"BulkInputServiceGroup": {
		"entries": "A list of service group entries.",
	},
	"BulkUpdateContactGroup": {
		"entries": "A list of contact group entries.",
	},
	"BulkUpdateFolder": {
		"entries": "A list of folder entries.",
	},
	"BulkUpdateHost": {
		"entries": "A list of host entries.",
	},
	"BulkUpdateHostGroup": {
		"entries": "A list of host group entries.",
	},
	"BulkUpdateServiceGroup": {
		"entries": "A list of service group entries.",
	},
	"ChangeEventState": {
		"new_state": "The state",
	},
	"ChangeStateWithParams": {
		"filter_type": "The way you would like to filter events.",
		"new_state": "The state",
	},
	"ChangeStateWithQuery": {
		"filter_type": "The way you would like to filter events.",
		"new_state": "The state",
		"query": "An query expression of the Livestatus 'eventconsoleevents' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
	},
	"ChangesFields": {
		"action_name": "The action carried out",
		"id": "The change identifier",
		"time": "The date and time the change was made.",
		"user_id": "The user who made the change",
	},
	"CheckboxHostEventType": {
		"value": "Select the host event types and transitions this rule should handle. Note: If you activate this option and do not also specify service event types then this rule will never hold for service notifications! Note: You can only match on event types created by the core.",
	},
	"CheckboxMatchHostTags": {
		"value": "Match host tags with the following parameters",
	},
	"CheckboxServiceEventType": {
		"value": "Select the service event types and transitions this rule should handle. Note: If you activate this option and do not also specify host event types then this rule will never hold for host notifications! Note: You can only match on event types created by the core",
	},
	"CheckboxWithFromToServiceLevels": {
		"value": "Host or service must be in the following service level to get notification",
	},
	"CheckboxWithListOfLabels": {
		"value": "A list of key, value label pairs",
	},
	"CheckboxWithListOfServiceGroupsRegex": {
		"value": "The service group alias must not match one of the following regular expressions. For host events this condition is simply ignored. The text entered here is handled as a regular expression pattern. The pattern is applied as infix search. Add a leading ^ to make it match from the beginning and/or a...",
	},
	"CiscoPasswordStore": {
		"store_id": "A password store ID",
	},
	"CiscoWebexPluginCreate": {
		"disable_ssl_cert_verification": "Ignore unverified HTTPS request warnings. Use with caution.",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"ClusterCreateAttribute": {
		"additional_ipv4addresses": "A list of IPv4 addresses.",
		"additional_ipv6addresses": "A list of IPv6 addresses.",
		"alias": "Add a comment or describe this host",
		"contactgroups": "Only members of the contact groups listed here have Setup permission for the host/folder. Optionally, you can make these contact groups automatically monitor contacts. The assignment of hosts to contact groups can also be defined by <a href='wato.py?mode=edit_ruleset&varname=host_contactgroups'>r...",
		"inventory_failed": "Whether or not the last bulk discovery failed. It is set to True once it fails and unset in case a later discovery succeeds.",
		"ipaddress": "An IPv4 address.",
		"ipv6address": "An IPv6 address.",
		"labels": "Labels allow you to flexibly group your hosts in order to refer to them later at other places in Checkmk, e.g. in rule chains.<br><b>Label format:</b> key:value<br><br>Checkmk does not perform any validation on the labels you use.",
		"locked_attributes": "Name of host attributes which are locked in the UI.",
		"locked_by": "Identity of the entity which locked the locked_attributes. The identity is built out of the Site ID, the program name and the connection ID.",
		"management_address": "Address (IPv4, IPv6 or hostname) under which the management board can be reached.",
		"management_ipmi_credentials": "IPMI credentials",
		"management_protocol": "The protocol used to connect to the management board. Valid options are: * `none` - No management board * `snmp` - Connect using SNMP * `ipmi` - Connect using IPMI",
		"management_snmp_community": "SNMP credentials",
		"network_scan": "Configuration for automatic network scan. Pings will besent to each IP address in the configured ranges to checkif a host is up or down. Each found host will be added tothe folder by it's hostname (if possible) or IP address.",
		"parents": "A list of parents of this host.",
		"site": "The site that should monitor this host.",
		"snmp_community": "The SNMP access configuration. A configured SNMP v1/v2 community here will have precedence over any configured SNMP community rule. For this attribute to take effect, the attribute `tag_snmp_ds` needs to be set first.",
		"tag_address_family": "Choices: * `\"ip-v4-only\"`: IPv4 only * `\"ip-v6-only\"`: IPv6 only * `\"ip-v4v6\"`: IPv4/IPv6 dual-stack * `\"no-ip\"`: No IP",
		"tag_agent": "Choices: * `\"cmk-agent\"`: API integrations if configured, else Checkmk agent * `\"all-agents\"`: Configured API integrations and Checkmk agent * `\"special-agents\"`: Configured API integrations, no Checkmk agent * `\"no-agent\"`: No API integrations, no Checkmk agent",
		"tag_criticality": "Choices: * `\"prod\"`: Productive system * `\"critical\"`: Business critical * `\"test\"`: Test system * `\"offline\"`: Do not monitor this host",
		"tag_networking": "Choices: * `\"lan\"`: Local network (low latency) * `\"wan\"`: WAN (high latency) * `\"dmz\"`: DMZ (low latency, secure access)",
		"tag_piggyback": "By default, each host has a piggyback data source.<br><br><b>Use piggyback data from other hosts if present:</b><br>If selected, the <tt>Check_MK</tt> service of this host will process the piggyback data, but will not warn if no piggyback data is available. The associated discovered services woul...",
		"tag_snmp_ds": "Choices: * `\"no-snmp\"`: No SNMP * `\"snmp-v2\"`: SNMP v2 or v3 * `\"snmp-v1\"`: SNMP v1",
	},
	"CommentAttributes": {
		"author": "The author of the comment",
		"comment": "The comment itself",
		"entry_time": "The timestamp from when the comment was created.",
		"host_name": "The host name.",
		"id": "The comment ID",
		"is_service": "True if the comment is from a service or else it's False.",
		"persistent": "If true, the comment will be persisted",
		"service_description": "The service description the comment belongs to.",
	},
	"CommentCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of comment objects.",
	},
	"CommentObject": {
		"domainType": "The domain type of the object.",
		"extensions": "The attributes of a service/host comment.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"ConcreteDisabledNotifications": {
		"disable": "Option if all notifications should be temporarily disabled",
		"timerange": "A custom timerange during which notifications are disabled",
	},
	"ConcreteHostTagGroup": {
		"domainType": "The domain type of the object.",
		"extensions": "Additional fields for objects of this type.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"ConcreteTimePeriodException": {
		"date": "The date of the time period exception.8601 profile",
	},
	"ConcreteTimeRange": {
		"end": "The hour of the time period.",
		"start": "The hour of the time period.",
	},
	"ConcreteTimeRangeActive": {
		"day": "The day for which the time ranges are specified",
	},
	"ConcreteUserContactOption": {
		"email": "The mail address of the user.",
		"fallback_contact": "In case none of the notification rules handle a certain event a notification will be sent to the specified email",
	},
	"ConcreteUserInterfaceAttributes": {
		"interface_theme": "The theme of the interface",
		"mega_menu_icons": "This option decides if colored icon should be shown foe every entry in the mega menus or alternatively only for the headlines (the 'topics')",
		"navigation_bar_icons": "This option decides if icons in the navigation bar should show/hide the respective titles",
		"show_mode": "This option decides what show mode should be used for unvisited menus. Alternatively, this option can also be used to enforce show more removing the three dots for all menus.",
		"sidebar_position": "The position of the sidebar",
	},
	"ConfigurationConnectionAttributes": {
		"direct_login_to_web_gui_allowed": "When enabled, this site is marked for synchronisation every time a Web GUI related option is changed and users are allowed to login to the Web GUI of this site.",
		"disable_remote_configuration": "It is a good idea to disable access to Setup completely on the remote site. Otherwise a user who does not now about the replication could make local changes that are overridden at the next configuration activation.",
		"enable_replication": "Replication allows you to manage several monitoring sites with a logically centralized setup. Remote sites receive their configuration from the central sites.",
		"ignore_tls_errors": "This might be needed to make the synchronization accept problems with SSL certificates when using an SSL secured connection.",
		"replicate_event_console": "This option enables the distribution of global settings and rules of the Event Console to the remote site. Any change in the local Event Console settings will mark the site as need sync. A synchronization will automatically reload the Event Console of the remote site.",
		"replicate_extensions": "If you enable the replication of MKPs then during each Activate Changes MKPs that are installed on your central site and all other files below the ~/local/ directory will be also transferred to the remote site. Note: all other MKPs and files below ~/local/ on the remote site will be removed.",
		"url_of_remote_site": "URL of the remote Checkmk including /check_mk/. This URL is in many cases the same as the URL-Prefix but with check_mk/ appended, but it must always be an absolute URL.",
		"user_sync": "By default the users are synchronized automatically in the interval configured in the connection. For example the LDAP connector synchronizes the users every five minutes by default. The interval can be changed for each connection individually in the connection settings. Please note that the sync...",
	},
	"ConfigurationConnectionAttributes1": {
		"direct_login_to_web_gui_allowed": "When enabled, this site is marked for synchronisation every time a Web GUI related option is changed and users are allowed to login to the Web GUI of this site.",
		"disable_remote_configuration": "It is a good idea to disable access to Setup completely on the remote site. Otherwise a user who does not now about the replication could make local changes that are overridden at the next configuration activation.",
		"enable_replication": "Replication allows you to manage several monitoring sites with a logically centralized setup. Remote sites receive their configuration from the central sites.",
		"ignore_tls_errors": "This might be needed to make the synchronization accept problems with SSL certificates when using an SSL secured connection.",
		"replicate_event_console": "This option enables the distribution of global settings and rules of the Event Console to the remote site. Any change in the local Event Console settings will mark the site as need sync. A synchronization will automatically reload the Event Console of the remote site.",
		"replicate_extensions": "If you enable the replication of MKPs then during each Activate Changes MKPs that are installed on your central site and all other files below the ~/local/ directory will be also transferred to the remote site. Note: all other MKPs and files below ~/local/ on the remote site will be removed.",
		"url_of_remote_site": "URL of the remote Checkmk including /check_mk/. This URL is in many cases the same as the URL-Prefix but with check_mk/ appended, but it must always be an absolute URL.",
		"user_sync": "By default the users are synchronized automatically in the interval configured in the connection. For example the LDAP connector synchronizes the users every five minutes by default. The interval can be changed for each connection individually in the connection settings. Please note that the sync...",
	},
	"ConnectionMode": {
		"connection_mode": "This configures the communication direction of this host. * `pull-agent` (default) - The server will try to contact the monitored host and pull the data by initializing a TCP connection * `push-agent` - the host is expected to send the data to the monitoring server without being triggered",
	},
	"ContactGroup": {
		"domainType": "The domain type of the object.",
		"extensions": "All the attributes of the domain object.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"ContactGroupCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of contact group objects.",
	},
	"CreateClusterHost": {
		"attributes": "Attributes to set on the newly created host.",
		"folder": "The path name of the folder. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"host_name": "The hostname of the cluster host.",
		"nodes": "Nodes where the newly created host should be the cluster-container of.",
	},
	"CreateFolder": {
		"attributes": "Specific attributes to apply for all hosts in this folder (among other things).",
		"name": "The filesystem directory name (not path!) of the folder. No slashes are allowed.",
		"parent": "The folder in which the new folder shall be placed in. The root-folder is specified by '/'. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"title": "The folder title as displayed in the user interface.",
	},
	"CreateHost": {
		"attributes": "Attributes to set on the newly created host.",
		"folder": "The path name of the folder. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"host_name": "The hostname or IP address of the host to be created.",
	},
	"CreateHostComment": {
		"comment": "The comment which will be stored for the host.",
		"comment_type": "How you would like to leave a comment.",
		"host_name": "The host name",
		"persistent": "If set, the comment will persist a restart.",
	},
	"CreateHostDowntime": {
		"downtime_type": "The type of downtime to create.",
		"duration": "Duration in minutes. When set, the downtime does not begin automatically at a nominated time, but when a real problem status appears for the host. Consequencely, the start_time/end_time is only the time window in which the scheduled downtime can begin.",
		"end_time": "The end datetime of the new downtime. The format has to conform to the ISO 8601 profile",
		"host_name": "The hostname or IP address itself.",
		"recur": "The recurring mode of the new downtime. Available modes are: * fixed * hour * day * week * second_week * fourth_week * weekday_start * weekday_end * day_of_month This only works when using the Enterprise Editions. Defaults to 'fixed'.",
		"start_time": "The start datetime of the new downtime. The format has to conform to the ISO 8601 profile",
	},
	"CreateHostGroupDowntime": {
		"downtime_type": "The type of downtime to create.",
		"duration": "Duration in minutes. When set, the downtime does not begin automatically at a nominated time, but when a real problem status appears for the host. Consequencely, the start_time/end_time is only the time window in which the scheduled downtime can begin.",
		"end_time": "The end datetime of the new downtime. The format has to conform to the ISO 8601 profile",
		"hostgroup_name": "The name of the host group. A downtime will be scheduled for all hosts in this host group.",
		"recur": "The recurring mode of the new downtime. Available modes are: * fixed * hour * day * week * second_week * fourth_week * weekday_start * weekday_end * day_of_month This only works when using the Enterprise Editions. Defaults to 'fixed'.",
		"start_time": "The start datetime of the new downtime. The format has to conform to the ISO 8601 profile",
	},
	"CreateHostQueryComment": {
		"comment": "The comment which will be stored for the host.",
		"comment_type": "How you would like to leave a comment.",
		"persistent": "If set, the comment will persist a restart.",
		"query": "An query expression of the Livestatus 'hosts' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
	},
	"CreateHostQueryDowntime": {
		"downtime_type": "The type of downtime to create.",
		"duration": "Duration in minutes. When set, the downtime does not begin automatically at a nominated time, but when a real problem status appears for the host. Consequencely, the start_time/end_time is only the time window in which the scheduled downtime can begin.",
		"end_time": "The end datetime of the new downtime. The format has to conform to the ISO 8601 profile",
		"query": "An query expression of the Livestatus 'hosts' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
		"recur": "The recurring mode of the new downtime. Available modes are: * fixed * hour * day * week * second_week * fourth_week * weekday_start * weekday_end * day_of_month This only works when using the Enterprise Editions. Defaults to 'fixed'.",
		"start_time": "The start datetime of the new downtime. The format has to conform to the ISO 8601 profile",
	},
	"CreateServiceComment": {
		"comment": "The comment which will be stored for the host.",
		"comment_type": "How you would like to leave a comment.",
		"host_name": "The host name",
		"persistent": "If set, the comment will persist a restart.",
		"service_description": "The service description for which the comment is for. No exception is raised when the specified service description does not exist",
	},
	"CreateServiceDowntime": {
		"downtime_type": "The type of downtime to create.",
		"duration": "Duration in minutes. When set, the downtime does not begin automatically at a nominated time, but when a real problem status appears for the service. Consequencely, the start_time/end_time is only the time window in which the scheduled downtime can begin.",
		"end_time": "The end datetime of the new downtime. The format has to conform to the ISO 8601 profile",
		"recur": "The recurring mode of the new downtime. Available modes are: * fixed * hour * day * week * second_week * fourth_week * weekday_start * weekday_end * day_of_month This only works when using the Enterprise Editions. Defaults to 'fixed'.",
		"service_descriptions": "The service description of the service, whose problems shall be acknowledged.",
		"start_time": "The start datetime of the new downtime. The format has to conform to the ISO 8601 profile",
	},
	"CreateServiceGroupDowntime": {
		"downtime_type": "The type of downtime to create.",
		"duration": "Duration in minutes. When set, the downtime does not begin automatically at a nominated time, but when a real problem status appears for the host. Consequencely, the start_time/end_time is only the time window in which the scheduled downtime can begin.",
		"end_time": "The end datetime of the new downtime. The format has to conform to the ISO 8601 profile",
		"recur": "The recurring mode of the new downtime. Available modes are: * fixed * hour * day * week * second_week * fourth_week * weekday_start * weekday_end * day_of_month This only works when using the Enterprise Editions. Defaults to 'fixed'.",
		"servicegroup_name": "The name of the service group. Any host having a service in this group will be A downtime will be scheduled for all hosts in this group.",
		"start_time": "The start datetime of the new downtime. The format has to conform to the ISO 8601 profile",
	},
	"CreateServiceQueryComment": {
		"comment": "The comment which will be stored for the host.",
		"comment_type": "How you would like to leave a comment.",
		"persistent": "If set, the comment will persist a restart.",
		"query": "An query expression of the Livestatus 'services' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
	},
	"CreateServiceQueryDowntime": {
		"downtime_type": "The type of downtime to create.",
		"duration": "Duration in minutes. When set, the downtime does not begin automatically at a nominated time, but when a real problem status appears for the service. Consequencely, the start_time/end_time is only the time window in which the scheduled downtime can begin.",
		"end_time": "The end datetime of the new downtime. The format has to conform to the ISO 8601 profile",
		"query": "An query expression of the Livestatus 'services' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
		"recur": "The recurring mode of the new downtime. Available modes are: * fixed * hour * day * week * second_week * fourth_week * weekday_start * weekday_end * day_of_month This only works when using the Enterprise Editions. Defaults to 'fixed'.",
		"start_time": "The start datetime of the new downtime. The format has to conform to the ISO 8601 profile",
	},
	"CreateTimePeriod": {
		"active_time_ranges": "The list of active time ranges.",
		"alias": "An alias for the time period.",
		"exceptions": "A list of additional time ranges to be added.",
		"exclude": "A list of time period aliases whose periods are excluded.",
		"name": "A unique name for the time period.",
	},
	"CreateUser": {
		"auth_option": "Authentication option for the user",
		"authorized_sites": "The names of the sites the user is authorized to handle.",
		"contact_options": "Contact settings for the user",
		"contactgroups": "Assign the user to one or multiple contact groups. If no contact group is specified then no monitoring contact will be created for the user.",
		"disable_login": "The user can be blocked from login but will remain part of the site. The disabling does not affect notification and alerts.",
		"fullname": "The alias or full name of the user",
		"idle_timeout": "Idle timeout for the user. Per default, the global configuration is used.",
		"language": "Configure the language to be used by the user in the user interface. Omitting this will configure the default language.",
		"roles": "The list of assigned roles to the user",
		"temperature_unit": "Configure the temperature unit used for graphs and perfometers. Omitting this field will configure the default temperature unit.",
		"username": "An unique username for the user",
	},
	"CreateUserRole": {
		"new_alias": "A new alias that you want to give to the newly created user role.",
		"new_role_id": "The new role id for the newly created user role.",
		"role_id": "Existing userrole that you want to clone.",
	},
	"CustomMacro": {
		"macro_name": "The name of the macro",
		"match_regex": "The text entered here is handled as a regular expression pattern",
	},
	"CustomTimeRange": {
		"end_time": "The end datetime of the time period. The format has to conform to the ISO 8601 profile",
		"start_time": "The start datetime of the time period. The format has to conform to the ISO 8601 profile",
	},
	"DateTimeRange": {
		"end_time": "The end datetime of the time period. The format conforms to the ISO 8601 profile",
		"start_time": "The start datetime of the time period. The format conforms to the ISO 8601 profile",
	},
	"DeleteCommentById": {
		"comment_id": "An integer representing a comment ID.",
		"delete_type": "How you would like to delete comments.",
	},
	"DeleteCommentsByParams": {
		"delete_type": "How you would like to delete comments.",
		"host_name": "The host name",
		"service_descriptions": "If set, the comments for the listed services of the specified host will be removed. If a service has multiple comments then all will be removed",
	},
	"DeleteCommentsByQuery": {
		"delete_type": "How you would like to delete comments.",
		"query": "An query expression of the Livestatus 'comments' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
	},
	"DeleteDowntimeById": {
		"delete_type": "The option how to delete a downtime.",
		"downtime_id": "The id of the downtime",
	},
	"DeleteDowntimeByName": {
		"delete_type": "The option how to delete a downtime.",
		"host_name": "If set alone, then all downtimes of the host will be removed.",
		"service_descriptions": "If set, the downtimes of the listed services of the specified host will be removed. If a service has multiple downtimes then all will be removed",
	},
	"DeleteDowntimeByQuery": {
		"delete_type": "The option how to delete a downtime.",
		"query": "An query expression of the Livestatus 'downtimes' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
	},
	"DirectMapping": {
		"hostname": "The hostname to be replaced.",
		"replace_with": "The replacement string.",
	},
	"DisabledNotifications": {
		"disable": "Option if all notifications should be temporarily disabled",
		"timerange": "A custom timerange during which notifications are disabled",
	},
	"DiscoverServices": {
		"host_name": "The host of the service which shall be updated.",
		"mode": "The mode of the discovery action. The 'refresh' mode starts a new service discovery which will contact the host and identify undecided and vanished services and host labels. Those services and host labels can be added or removed accordingly with the 'fix_all' mode. The 'tabula_rasa' mode combines...",
	},
	"DiscoverServicesDeprecated": {
		"mode": "The mode of the discovery action. The 'refresh' mode starts a new service discovery which will contact the host and identify undecided and vanished services and host labels. Those services and host labels can be added or removed accordingly with the 'fix_all' mode. The 'tabula_rasa' mode combines...",
	},
	"DiscoveryBackgroundJobStatusObject": {
		"domainType": "The domain type of the object",
		"extensions": "The attributes of the background job",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"DomainObject": {
		"domainType": "The \"domain-type\" of the object.",
		"extensions": "All the attributes of the domain object.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"DomainObjectCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "The collection itself. Each entry in here is part of the collection.",
	},
	"ECEventAttributes": {
		"application": "The syslog tag/application this event originated from.",
		"comment": "The event comment.",
		"contact": "The event contact information.",
		"count": "The number of occurrences of this event within a period.",
		"facility": "The syslog facility.",
		"host": "The host name. No exception is raised when the specified host name does not exist",
		"ipaddress": "The IP address where the event originated.",
		"phase": "The event phase, open or ack",
		"priority": "The syslog priority.",
		"rule_id": "The ID of the rule.",
		"service_level": "The service level for this event.",
		"state": "The state",
		"text": "The event message text",
	},
	"ECEventResponse": {
		"domainType": "The domain type of the object.",
		"extensions": "The configuration attributes of a site.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"EditUserRole": {
		"new_alias": "New alias for the userrole that must be unique.",
		"new_basedon": "A builtin user role that you want the user role to be based on.",
		"new_permissions": "A map of permission names to their state. The following values can be set: 'yes' - the permission is active for this role.'no' - the permission is deactivated for this role, even if it was active in the role it was based on.'default' - takes the activation state from the role this role was based on.",
		"new_role_id": "New role_id for the userrole that must be unique.",
	},
	"EventConsoleResponseCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of site configuration objects.",
	},
	"FailedHosts": {
		"failed_hosts": "Detailed error messages on hosts failing the action",
		"succeeded_hosts": "The list of succeeded host objects",
	},
	"FilterById": {
		"event_id": "The event console ID",
		"filter_type": "The way you would like to filter events.",
	},
	"FilterByParams": {
		"filter_type": "The way you would like to filter events.",
	},
	"FilterByQuery": {
		"filter_type": "The way you would like to filter events.",
		"query": "An query expression of the Livestatus 'eventconsoleevents' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
	},
	"FilterParams": {
		"application": "Show events that originated from this app.",
		"host": "The host name. No exception is raised when the specified host name does not exist",
		"phase": "The event phase, open or ack",
		"state": "The state",
	},
	"FilterParamsUpdateAndAcknowledge": {
		"application": "Show events that originated from this app.",
		"host": "The host name. No exception is raised when the specified host name does not exist",
		"state": "The state",
	},
	"Folder": {
		"domainType": "The domain type of the object.",
		"extensions": "Data and Meta-Data of this object.",
		"id": "The full path of the folder, tilde-separated.",
		"links": "list of links to other resources.",
		"members": "Specific collections or actions applicable to this object.",
		"title": "The human readable title for this folder.",
	},
	"FolderCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of folder objects.",
	},
	"FolderCreateAttribute": {
		"contactgroups": "Only members of the contact groups listed here have Setup permission for the host/folder. Optionally, you can make these contact groups automatically monitor contacts. The assignment of hosts to contact groups can also be defined by <a href='wato.py?mode=edit_ruleset&varname=host_contactgroups'>r...",
		"labels": "Labels allow you to flexibly group your hosts in order to refer to them later at other places in Checkmk, e.g. in rule chains.<br><b>Label format:</b> key:value<br><br>Checkmk does not perform any validation on the labels you use.",
		"management_ipmi_credentials": "IPMI credentials",
		"management_protocol": "The protocol used to connect to the management board. Valid options are: * `none` - No management board * `snmp` - Connect using SNMP * `ipmi` - Connect using IPMI",
		"management_snmp_community": "SNMP credentials",
		"network_scan": "Configuration for automatic network scan. Pings will besent to each IP address in the configured ranges to checkif a host is up or down. Each found host will be added tothe folder by it's hostname (if possible) or IP address.",
		"parents": "A list of parents of this host.",
		"site": "The site that should monitor this host.",
		"snmp_community": "The SNMP access configuration. A configured SNMP v1/v2 community here will have precedence over any configured SNMP community rule. For this attribute to take effect, the attribute `tag_snmp_ds` needs to be set first.",
		"tag_address_family": "Choices: * `\"ip-v4-only\"`: IPv4 only * `\"ip-v6-only\"`: IPv6 only * `\"ip-v4v6\"`: IPv4/IPv6 dual-stack * `\"no-ip\"`: No IP",
		"tag_agent": "Choices: * `\"cmk-agent\"`: API integrations if configured, else Checkmk agent * `\"all-agents\"`: Configured API integrations and Checkmk agent * `\"special-agents\"`: Configured API integrations, no Checkmk agent * `\"no-agent\"`: No API integrations, no Checkmk agent",
		"tag_criticality": "Choices: * `\"prod\"`: Productive system * `\"critical\"`: Business critical * `\"test\"`: Test system * `\"offline\"`: Do not monitor this host",
		"tag_networking": "Choices: * `\"lan\"`: Local network (low latency) * `\"wan\"`: WAN (high latency) * `\"dmz\"`: DMZ (low latency, secure access)",
		"tag_piggyback": "By default, each host has a piggyback data source.<br><br><b>Use piggyback data from other hosts if present:</b><br>If selected, the <tt>Check_MK</tt> service of this host will process the piggyback data, but will not warn if no piggyback data is available. The associated discovered services woul...",
		"tag_snmp_ds": "Choices: * `\"no-snmp\"`: No SNMP * `\"snmp-v2\"`: SNMP v2 or v3 * `\"snmp-v1\"`: SNMP v1",
	},
	"FolderExtensions": {
		"attributes": "The folder's attributes. Hosts placed in this folder will inherit these attributes.",
		"path": "The full path of this folder, slash delimited.",
	},
	"FolderMembers": {
		"hosts": "A list of links pointing to the actual host-resources.",
		"move": "An action which triggers the move of this folder to another folder.",
	},
	"FolderUpdateAttribute": {
		"contactgroups": "Only members of the contact groups listed here have Setup permission for the host/folder. Optionally, you can make these contact groups automatically monitor contacts. The assignment of hosts to contact groups can also be defined by <a href='wato.py?mode=edit_ruleset&varname=host_contactgroups'>r...",
		"labels": "Labels allow you to flexibly group your hosts in order to refer to them later at other places in Checkmk, e.g. in rule chains.<br><b>Label format:</b> key:value<br><br>Checkmk does not perform any validation on the labels you use.",
		"management_ipmi_credentials": "IPMI credentials",
		"management_protocol": "The protocol used to connect to the management board. Valid options are: * `none` - No management board * `snmp` - Connect using SNMP * `ipmi` - Connect using IPMI",
		"management_snmp_community": "SNMP credentials",
		"network_scan": "Configuration for automatic network scan. Pings will besent to each IP address in the configured ranges to checkif a host is up or down. Each found host will be added tothe folder by it's hostname (if possible) or IP address.",
		"parents": "A list of parents of this host.",
		"site": "The site that should monitor this host.",
		"snmp_community": "The SNMP access configuration. A configured SNMP v1/v2 community here will have precedence over any configured SNMP community rule. For this attribute to take effect, the attribute `tag_snmp_ds` needs to be set first.",
		"tag_address_family": "Choices: * `\"ip-v4-only\"`: IPv4 only * `\"ip-v6-only\"`: IPv6 only * `\"ip-v4v6\"`: IPv4/IPv6 dual-stack * `\"no-ip\"`: No IP",
		"tag_agent": "Choices: * `\"cmk-agent\"`: API integrations if configured, else Checkmk agent * `\"all-agents\"`: Configured API integrations and Checkmk agent * `\"special-agents\"`: Configured API integrations, no Checkmk agent * `\"no-agent\"`: No API integrations, no Checkmk agent",
		"tag_criticality": "Choices: * `\"prod\"`: Productive system * `\"critical\"`: Business critical * `\"test\"`: Test system * `\"offline\"`: Do not monitor this host",
		"tag_networking": "Choices: * `\"lan\"`: Local network (low latency) * `\"wan\"`: WAN (high latency) * `\"dmz\"`: DMZ (low latency, secure access)",
		"tag_piggyback": "By default, each host has a piggyback data source.<br><br><b>Use piggyback data from other hosts if present:</b><br>If selected, the <tt>Check_MK</tt> service of this host will process the piggyback data, but will not warn if no piggyback data is available. The associated discovered services woul...",
		"tag_snmp_ds": "Choices: * `\"no-snmp\"`: No SNMP * `\"snmp-v2\"`: SNMP v2 or v3 * `\"snmp-v1\"`: SNMP v1",
	},
	"FolderViewAttribute": {
		"contactgroups": "Only members of the contact groups listed here have Setup permission for the host/folder. Optionally, you can make these contact groups automatically monitor contacts. The assignment of hosts to contact groups can also be defined by <a href='wato.py?mode=edit_ruleset&varname=host_contactgroups'>r...",
		"labels": "Labels allow you to flexibly group your hosts in order to refer to them later at other places in Checkmk, e.g. in rule chains.<br><b>Label format:</b> key:value<br><br>Checkmk does not perform any validation on the labels you use.",
		"management_ipmi_credentials": "IPMI credentials",
		"management_protocol": "The protocol used to connect to the management board. Valid options are: * `none` - No management board * `snmp` - Connect using SNMP * `ipmi` - Connect using IPMI",
		"management_snmp_community": "SNMP credentials",
		"meta_data": "Read only access to configured metadata.",
		"network_scan": "Configuration for automatic network scan. Pings will besent to each IP address in the configured ranges to checkif a host is up or down. Each found host will be added tothe folder by it's hostname (if possible) or IP address.",
		"network_scan_result": "Read only access to the network scan result",
		"parents": "A list of parents of this host.",
		"site": "The site that should monitor this host.",
		"snmp_community": "The SNMP access configuration. A configured SNMP v1/v2 community here will have precedence over any configured SNMP community rule. For this attribute to take effect, the attribute `tag_snmp_ds` needs to be set first.",
		"tag_piggyback": "By default, each host has a piggyback data source.<br><br><b>Use piggyback data from other hosts if present:</b><br>If selected, the <tt>Check_MK</tt> service of this host will process the piggyback data, but will not warn if no piggyback data is available. The associated discovered services woul...",
	},
	"FromEmailAndNameCheckbox": {
		"value": "The email address and visible name used in the From header of notifications messages. If no email address is specified the default address is OMD_SITE@FQDN is used. If the environment variable OMD_SITE is not set it defaults to checkmk",
	},
	"FromToNotificationNumbers": {
		"beginning_from": "Let through notifications counting from this number. The first notification always has the number 1",
		"up_to": "Let through notifications counting upto this number",
	},
	"GetGraph": {
		"graph_id": "The ID of the predefined graph. After activating the \"Show internal IDs\" in the \"display options\" of the Service view, you can see the ID of a predefined graph in the title of the graph.",
		"host_name": "The hostname to use.",
		"reduce": "Specify how to reduce a segment of data points to a single data point of the output metric. This can be useful to find spikes in your data that would be smoothed out by computing the average.",
		"service_description": "The service, whose data to request.",
		"site": "The name of the site. Even though this is optional, specifying a site will greatly improve performance in large distributed systems.",
		"time_range": "The time range from which to source the metrics.",
		"type": "Specify whether you want to receive a single metric (via metric_id), or a predefined graph containing multiple metrics (via graph_id).",
	},
	"GetMetric": {
		"host_name": "The hostname to use.",
		"metric_id": "The ID of the single metric.After activating the \"Show internal IDs\" in the \"display options\" of the Service view, you can see the ID of a single metric in the legend of the graph.",
		"reduce": "Specify how to reduce a segment of data points to a single data point of the output metric. This can be useful to find spikes in your data that would be smoothed out by computing the average.",
		"service_description": "The service, whose data to request.",
		"site": "The name of the site. Even though this is optional, specifying a site will greatly improve performance in large distributed systems.",
		"time_range": "The time range from which to source the metrics.",
		"type": "Specify whether you want to receive a single metric (via metric_id), or a predefined graph containing multiple metrics (via graph_id).",
	},
	"GraphCollection": {
		"metrics": "The actual graph data.",
		"step": "The interval between two samples in seconds.",
		"time_range": "The time range withing the samples of the response lie.",
	},
	"HTMLMailPluginCreate": {
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"Heartbeat": {
		"interval": "The heartbeat interval for the TCP connection.",
		"timeout": "The heartbeat timeout for the TCP connection.",
	},
	"Heartbeat1": {
		"interval": "The heartbeat interval for the TCP connection.",
		"timeout": "The heartbeat timeout for the TCP connection.",
	},
	"HostConfig": {
		"domainType": "The domain type of the object.",
		"extensions": "All the data and metadata of this host.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "All the members of the host object.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"HostConfigCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of host objects.",
	},
	"HostConfigSchemaInternal": {
		"is_cluster": "Indicates if the host is a cluster host.",
		"site": "The site the host is monitored on.",
	},
	"HostContactGroup": {
		"groups": "A list of contact groups.",
		"recurse_perms": "Give these groups also permission on all sub-folders.",
		"recurse_use": "Add these groups as contacts to all hosts in all sub-folders of this folder.",
		"use": "Add these contact groups to the host.",
		"use_for_services": "<p>Always add host contact groups also to its services.</p>With this option contact groups that are added to hosts are always being added to services, as well. This only makes a difference if you have assigned other contact groups to services via rules in <i>Host & Service Parameters</i>. As long...",
	},
	"HostCreateAttribute": {
		"additional_ipv4addresses": "A list of IPv4 addresses.",
		"additional_ipv6addresses": "A list of IPv6 addresses.",
		"alias": "Add a comment or describe this host",
		"contactgroups": "Only members of the contact groups listed here have Setup permission for the host/folder. Optionally, you can make these contact groups automatically monitor contacts. The assignment of hosts to contact groups can also be defined by <a href='wato.py?mode=edit_ruleset&varname=host_contactgroups'>r...",
		"inventory_failed": "Whether or not the last bulk discovery failed. It is set to True once it fails and unset in case a later discovery succeeds.",
		"ipaddress": "An IPv4 address.",
		"ipv6address": "An IPv6 address.",
		"labels": "Labels allow you to flexibly group your hosts in order to refer to them later at other places in Checkmk, e.g. in rule chains.<br><b>Label format:</b> key:value<br><br>Checkmk does not perform any validation on the labels you use.",
		"locked_attributes": "Name of host attributes which are locked in the UI.",
		"locked_by": "Identity of the entity which locked the locked_attributes. The identity is built out of the Site ID, the program name and the connection ID.",
		"management_address": "Address (IPv4, IPv6 or hostname) under which the management board can be reached.",
		"management_ipmi_credentials": "IPMI credentials",
		"management_protocol": "The protocol used to connect to the management board. Valid options are: * `none` - No management board * `snmp` - Connect using SNMP * `ipmi` - Connect using IPMI",
		"management_snmp_community": "SNMP credentials",
		"network_scan": "Configuration for automatic network scan. Pings will besent to each IP address in the configured ranges to checkif a host is up or down. Each found host will be added tothe folder by it's hostname (if possible) or IP address.",
		"parents": "A list of parents of this host.",
		"site": "The site that should monitor this host.",
		"snmp_community": "The SNMP access configuration. A configured SNMP v1/v2 community here will have precedence over any configured SNMP community rule. For this attribute to take effect, the attribute `tag_snmp_ds` needs to be set first.",
		"tag_address_family": "Choices: * `\"ip-v4-only\"`: IPv4 only * `\"ip-v6-only\"`: IPv6 only * `\"ip-v4v6\"`: IPv4/IPv6 dual-stack * `\"no-ip\"`: No IP",
		"tag_agent": "Choices: * `\"cmk-agent\"`: API integrations if configured, else Checkmk agent * `\"all-agents\"`: Configured API integrations and Checkmk agent * `\"special-agents\"`: Configured API integrations, no Checkmk agent * `\"no-agent\"`: No API integrations, no Checkmk agent",
		"tag_criticality": "Choices: * `\"prod\"`: Productive system * `\"critical\"`: Business critical * `\"test\"`: Test system * `\"offline\"`: Do not monitor this host",
		"tag_networking": "Choices: * `\"lan\"`: Local network (low latency) * `\"wan\"`: WAN (high latency) * `\"dmz\"`: DMZ (low latency, secure access)",
		"tag_piggyback": "By default, each host has a piggyback data source.<br><br><b>Use piggyback data from other hosts if present:</b><br>If selected, the <tt>Check_MK</tt> service of this host will process the piggyback data, but will not warn if no piggyback data is available. The associated discovered services woul...",
		"tag_snmp_ds": "Choices: * `\"no-snmp\"`: No SNMP * `\"snmp-v2\"`: SNMP v2 or v3 * `\"snmp-v1\"`: SNMP v1",
	},
	"HostExtensions": {
		"attributes": "Attributes of this host.",
		"cluster_nodes": "In the case this is a cluster host, these are the cluster nodes.",
		"effective_attributes": "All attributes of this host and all parent folders.",
		"folder": "The folder, in which this host resides. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"is_cluster": "If this is a cluster host, i.e. a container for other hosts.",
		"is_offline": "Whether the host is offline",
	},
	"HostExtensionsEffectiveAttributes": {
		"additional_ipv4addresses": "A list of IPv4 addresses.",
		"additional_ipv6addresses": "A list of IPv6 addresses.",
		"alias": "Add a comment or describe this host",
		"contactgroups": "Only members of the contact groups listed here have Setup permission for the host/folder. Optionally, you can make these contact groups automatically monitor contacts. The assignment of hosts to contact groups can also be defined by <a href='wato.py?mode=edit_ruleset&varname=host_contactgroups'>r...",
		"inventory_failed": "Whether or not the last bulk discovery failed. It is set to True once it fails and unset in case a later discovery succeeds.",
		"ipaddress": "An IPv4 address.",
		"ipv6address": "An IPv6 address.",
		"labels": "Labels allow you to flexibly group your hosts in order to refer to them later at other places in Checkmk, e.g. in rule chains.<br><b>Label format:</b> key:value<br><br>Checkmk does not perform any validation on the labels you use.",
		"locked_attributes": "Name of host attributes which are locked in the UI.",
		"locked_by": "Identity of the entity which locked the locked_attributes. The identity is built out of the Site ID, the program name and the connection ID.",
		"management_address": "Address (IPv4, IPv6 or hostname) under which the management board can be reached.",
		"management_ipmi_credentials": "IPMI credentials",
		"management_protocol": "The protocol used to connect to the management board. Valid options are: * `none` - No management board * `snmp` - Connect using SNMP * `ipmi` - Connect using IPMI",
		"management_snmp_community": "SNMP credentials",
		"meta_data": "Read only access to configured metadata.",
		"network_scan": "Configuration for automatic network scan. Pings will besent to each IP address in the configured ranges to checkif a host is up or down. Each found host will be added tothe folder by it's hostname (if possible) or IP address.",
		"network_scan_result": "Read only access to the network scan result",
		"parents": "A list of parents of this host.",
		"site": "The site that should monitor this host.",
		"snmp_community": "The SNMP access configuration. A configured SNMP v1/v2 community here will have precedence over any configured SNMP community rule. For this attribute to take effect, the attribute `tag_snmp_ds` needs to be set first.",
		"tag_piggyback": "By default, each host has a piggyback data source.<br><br><b>Use piggyback data from other hosts if present:</b><br>If selected, the <tt>Check_MK</tt> service of this host will process the piggyback data, but will not warn if no piggyback data is available. The associated discovered services woul...",
	},
	"HostGroup": {
		"domainType": "The domain type of the object.",
		"extensions": "All the attributes of the domain object.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"HostGroupCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of host group objects.",
	},
	"HostMembers": {
		"folder_config": "The folder in which this host resides. It is represented by a hexadecimal identifier which is it's 'primary key'. The folder can be accessed via the `self`-link provided in the links array.",
	},
	"HostOrServiceCondition": {
		"match_on": "A list of string matching regular expressions.",
		"operator": "How the hosts or services should be matched. * one_of - will match if any of the hosts or services is matched * none_of - will match if none of the hosts are matched. In other words: will match all hosts or services which are not specified.",
	},
	"HostTag": {
		"aux_tags": "The list of auxiliary tag ids. Built-in tags (ip-v4, ip-v6, snmp, tcp, ping) and custom defined tags are allowed.",
		"ident": "An unique id for the tag",
		"title": "The title of the tag",
	},
	"HostTag1": {
		"aux_tags": "The auxiliary tags this tag included in.",
		"id": "The unique identifier of this host tag",
		"title": "The title of this host tag",
	},
	"HostTagExtensions": {
		"tags": "The list of tags in this group.",
		"topic": "The topic this host tag group is organized in.",
	},
	"HostTagGroupCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of host tag group objects.",
	},
	"HostUpdateAttribute": {
		"additional_ipv4addresses": "A list of IPv4 addresses.",
		"additional_ipv6addresses": "A list of IPv6 addresses.",
		"alias": "Add a comment or describe this host",
		"contactgroups": "Only members of the contact groups listed here have Setup permission for the host/folder. Optionally, you can make these contact groups automatically monitor contacts. The assignment of hosts to contact groups can also be defined by <a href='wato.py?mode=edit_ruleset&varname=host_contactgroups'>r...",
		"inventory_failed": "Whether or not the last bulk discovery failed. It is set to True once it fails and unset in case a later discovery succeeds.",
		"ipaddress": "An IPv4 address.",
		"ipv6address": "An IPv6 address.",
		"labels": "Labels allow you to flexibly group your hosts in order to refer to them later at other places in Checkmk, e.g. in rule chains.<br><b>Label format:</b> key:value<br><br>Checkmk does not perform any validation on the labels you use.",
		"locked_attributes": "Name of host attributes which are locked in the UI.",
		"locked_by": "Identity of the entity which locked the locked_attributes. The identity is built out of the Site ID, the program name and the connection ID.",
		"management_address": "Address (IPv4, IPv6 or hostname) under which the management board can be reached.",
		"management_ipmi_credentials": "IPMI credentials",
		"management_protocol": "The protocol used to connect to the management board. Valid options are: * `none` - No management board * `snmp` - Connect using SNMP * `ipmi` - Connect using IPMI",
		"management_snmp_community": "SNMP credentials",
		"network_scan": "Configuration for automatic network scan. Pings will besent to each IP address in the configured ranges to checkif a host is up or down. Each found host will be added tothe folder by it's hostname (if possible) or IP address.",
		"parents": "A list of parents of this host.",
		"site": "The site that should monitor this host.",
		"snmp_community": "The SNMP access configuration. A configured SNMP v1/v2 community here will have precedence over any configured SNMP community rule. For this attribute to take effect, the attribute `tag_snmp_ds` needs to be set first.",
		"tag_address_family": "Choices: * `\"ip-v4-only\"`: IPv4 only * `\"ip-v6-only\"`: IPv6 only * `\"ip-v4v6\"`: IPv4/IPv6 dual-stack * `\"no-ip\"`: No IP",
		"tag_agent": "Choices: * `\"cmk-agent\"`: API integrations if configured, else Checkmk agent * `\"all-agents\"`: Configured API integrations and Checkmk agent * `\"special-agents\"`: Configured API integrations, no Checkmk agent * `\"no-agent\"`: No API integrations, no Checkmk agent",
		"tag_criticality": "Choices: * `\"prod\"`: Productive system * `\"critical\"`: Business critical * `\"test\"`: Test system * `\"offline\"`: Do not monitor this host",
		"tag_networking": "Choices: * `\"lan\"`: Local network (low latency) * `\"wan\"`: WAN (high latency) * `\"dmz\"`: DMZ (low latency, secure access)",
		"tag_piggyback": "By default, each host has a piggyback data source.<br><br><b>Use piggyback data from other hosts if present:</b><br>If selected, the <tt>Check_MK</tt> service of this host will process the piggyback data, but will not warn if no piggyback data is available. The associated discovered services woul...",
		"tag_snmp_ds": "Choices: * `\"no-snmp\"`: No SNMP * `\"snmp-v2\"`: SNMP v2 or v3 * `\"snmp-v1\"`: SNMP v1",
	},
	"HostViewAttribute": {
		"additional_ipv4addresses": "A list of IPv4 addresses.",
		"additional_ipv6addresses": "A list of IPv6 addresses.",
		"alias": "Add a comment or describe this host",
		"contactgroups": "Only members of the contact groups listed here have Setup permission for the host/folder. Optionally, you can make these contact groups automatically monitor contacts. The assignment of hosts to contact groups can also be defined by <a href='wato.py?mode=edit_ruleset&varname=host_contactgroups'>r...",
		"inventory_failed": "Whether or not the last bulk discovery failed. It is set to True once it fails and unset in case a later discovery succeeds.",
		"ipaddress": "An IPv4 address.",
		"ipv6address": "An IPv6 address.",
		"labels": "Labels allow you to flexibly group your hosts in order to refer to them later at other places in Checkmk, e.g. in rule chains.<br><b>Label format:</b> key:value<br><br>Checkmk does not perform any validation on the labels you use.",
		"locked_attributes": "Name of host attributes which are locked in the UI.",
		"locked_by": "Identity of the entity which locked the locked_attributes. The identity is built out of the Site ID, the program name and the connection ID.",
		"management_address": "Address (IPv4, IPv6 or hostname) under which the management board can be reached.",
		"management_ipmi_credentials": "IPMI credentials",
		"management_protocol": "The protocol used to connect to the management board. Valid options are: * `none` - No management board * `snmp` - Connect using SNMP * `ipmi` - Connect using IPMI",
		"management_snmp_community": "SNMP credentials",
		"meta_data": "Read only access to configured metadata.",
		"network_scan": "Configuration for automatic network scan. Pings will besent to each IP address in the configured ranges to checkif a host is up or down. Each found host will be added tothe folder by it's hostname (if possible) or IP address.",
		"network_scan_result": "Read only access to the network scan result",
		"parents": "A list of parents of this host.",
		"site": "The site that should monitor this host.",
		"snmp_community": "The SNMP access configuration. A configured SNMP v1/v2 community here will have precedence over any configured SNMP community rule. For this attribute to take effect, the attribute `tag_snmp_ds` needs to be set first.",
		"tag_piggyback": "By default, each host has a piggyback data source.<br><br><b>Use piggyback data from other hosts if present:</b><br>If selected, the <tt>Check_MK</tt> service of this host will process the piggyback data, but will not warn if no piggyback data is available. The associated discovered services woul...",
	},
	"IPAddressRange": {
		"from_address": "The first IPv4 address of this range.",
		"to_address": "The last IPv4 address of this range.",
		"type": "A range of addresses.",
	},
	"IPAddresses": {
		"type": "A list of single IPv4 addresses.",
	},
	"IPNetwork": {
		"network": "A IPv4 network in CIDR notation. Minimum prefix length is 8 bit, maximum prefix length is 30 bit. Valid examples: * `192.168.0.0/24` * `192.168.0.0/255.255.255.0`",
		"type": "A single IPv4 network in CIDR notation.",
	},
	"IPRegexp": {
		"regexp_list": "A list of regular expressions which are matched against the found IP addresses. The matches will be excluded from the result.",
		"type": "IPv4 addresses which match a regexp pattern",
	},
	"IdleOption": {
		"duration": "The duration in seconds of the individual idle timeout if individual is selected as idle timeout option.",
		"option": "Specify if the idle timeout should use the global configuration, be disabled or use an individual duration",
	},
	"IlertPasswordStoreID": {
		"store_id": "A password store ID",
	},
	"IlertPluginCreate": {
		"custom_summary_for_host_alerts": "A custom summary for host alerts",
		"custom_summary_for_service_alerts": "A custom summary for service alerts",
		"disable_ssl_cert_verification": "Ignore unverified HTTPS request warnings. Use with caution.",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"notification_priority": "HIGH - with escalation, LOW - without escalation",
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"IncidentParams": {
		"caller": "Caller is the user on behalf of whom the incident is being reported within ServiceNow.",
	},
	"InputContactGroup": {
		"alias": "The name used for displaying in the GUI.",
		"name": "The name of the contact group.",
	},
	"InputHostGroup": {
		"alias": "The name used for displaying in the GUI.",
		"name": "A name used as identifier",
	},
	"InputHostTagGroup": {
		"help": "A help description for the tag group",
		"ident": "An id for the host tag group",
		"tags": "A list of host tags belonging to the host tag group",
		"title": "A title for the host tag",
		"topic": "Different tags can be grouped in a topic",
	},
	"InputPassword": {
		"comment": "A comment for the password",
		"documentation_url": "An optional URL pointing to documentation or any other page. You can use either global URLs (beginning with http://), absolute local urls (beginning with /) or relative URLs (that are relative to check_mk/).",
		"ident": "An unique identifier for the password",
		"owner": "Each password is owned by a group of users which are able to edit, delete and use existing passwords.",
		"password": "The password string",
		"shared": "The list of members to share the password with",
		"title": "A title for the password",
	},
	"InputRuleObject": {
		"conditions": "Conditions.",
		"folder": "The path name of the folder. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"properties": "Configuration values for rules.",
		"ruleset": "Name of rule set.",
		"value_raw": "The raw parameter value for this rule. To create the correct structure, for now use the 'export for API' menu item in the Rule Editor of the GUI. The value is expected to be a valid Python type.",
	},
	"InputServiceGroup": {
		"alias": "The name used for displaying in the GUI.",
		"name": "A name used as identifier",
	},
	"InstalledVersions": {
		"demo": "Whether this is a demo version or not.",
		"edition": "The Checkmk edition.",
		"group": "The Apache WSGI application group this call was made on.",
		"rest_api": "The REST-API version",
		"site": "The site where this API call was made on.",
		"versions": "Some version numbers",
	},
	"JiraPluginCreate": {
		"disable_ssl_cert_verification": "Ignore unverified HTTPS request warnings. Use with caution.",
		"host_custom_id": "The numerical JIRA custom field ID for host problems",
		"host_summary": "Here you are allowed to use all macros that are defined in the notification context",
		"issue_type_id": "The numerical JIRA issue type ID. If not set, it will be retrieved from a custom user attribute named jiraissuetype. If that is not set, the notification will fail",
		"jira_url": "Configure the JIRA URL here",
		"label": "Here you can set a custom label for new issues. If not set, 'monitoring' will be used",
		"monitoring_url": "Configure the base URL for the Monitoring Web-GUI here. Include the site name. Used for link to check_mk out of jira",
		"optional_timeout": "Here you can configure timeout settings.",
		"password": "The password entered here is stored in plain text within the monitoring site. This usually needed because the monitoring process needs to have access to the unencrypted password because it needs to submit it to authenticate with remote systems",
		"plugin_name": "The plugin name. Built-in plugins only.",
		"priority_id": "The numerical JIRA priority ID. If not set, it will be retrieved from a custom user attribute named jirapriority. If that is not set, the standard priority will be used",
		"project_id": "The numerical JIRA project ID. If not set, it will be retrieved from a custom user attribute named jiraproject. If that is not set, the notification will fail",
		"resolution_id": "The numerical JIRA resolution transition ID. 11 - 'To Do', 21 - 'In Progress', 31 - 'Done'",
		"service_custom_id": "The numerical JIRA custom field ID for service problems",
		"service_summary": "Here you are allowed to use all macros that are defined in the notification context",
		"site_custom_id": "The numerical ID of the JIRA custom field for sites. Please use this option if you have multiple sites in a distributed setup which send their notifications to the same JIRA instance",
		"username": "Configure the user name here",
	},
	"JobLogs": {
		"progress": "The list of progress related logs",
		"result": "The list of result related logs",
	},
	"LabelCondition": {
		"key": "The key of the label. e.g. 'os' in 'os:windows'",
		"operator": "How the label should be matched.",
		"value": "The value of the label. e.g. 'windows' in 'os:windows'",
	},
	"Link": {
		"body_params": "A map of values that shall be sent in the request body. If this is present,the request has to be sent with a content-type of 'application/json'.",
		"href": "The (absolute) address of the related resource. Any characters that are invalid in URLs must be URL encoded.",
		"method": "The HTTP method to use to traverse the link (get, post, put or delete)",
		"rel": "Indicates the nature of the relationship of the related resource to the resource that generated this representation",
		"title": "string that the consuming application may use to render the link without having to traverse the link in advance",
		"type": "The content-type that the linked resource will return",
	},
	"LinkHostUUID": {
		"uuid": "A valid UUID.",
	},
	"LockedBy": {
		"instance_id": "Instance ID",
		"program_id": "Program ID",
		"site_id": "Site ID",
	},
	"LogicalExpr": {
		"op": "The operator.",
	},
	"MSTeamsPluginCreate": {
		"affected_host_groups": "Enable/disable if we show affected host groups in the created message",
		"host_details": "Enable/disable the details for host notifications",
		"host_summary": "Enable/disable the summary for host notifications",
		"host_title": "Enable/disable the title for host notifications",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"plugin_name": "The plugin name. Built-in plugins only.",
		"service_details": "Enable/disable the details for service notifications",
		"service_summary": "Enable/disable the summary for service notifications",
		"service_title": "Enable/disable the title for service notifications",
	},
	"MSTeamsURLResponse": {
		"store_id": "A password store ID",
	},
	"MetaData": {
		"created_at": "When has this object been created.",
		"created_by": "The user id under which this object has been created.",
		"updated_at": "When this object was last changed.",
	},
	"Metric": {
		"color": "The color of the metric as displayed in Checkmk. Color is in HTML notation.",
		"data_points": "The samples of the metric.",
		"line_type": "The line type to use.",
		"title": "The title of the graph.",
	},
	"MkEventDPluginCreate": {
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"MoveFolder": {
		"destination": "Where the folder has to be moved to. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
	},
	"MoveHost": {
		"target_folder": "The path of the target folder where the host is supposed to be moved to. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
	},
	"MoveToFolder": {
		"folder": "The path name of the folder. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"position": "The type of position to move to.",
	},
	"MoveToSpecificRule": {
		"position": "The type of position to move to.",
		"rule_id": "The UUID of the rule to move after/before.",
	},
	"NetworkScan": {
		"addresses": "IPv4 addresses to include.",
		"exclude_addresses": "IPv4 addresses to exclude.",
		"max_parallel_pings": "Set the maximum number of concurrent pings sent to target IP addresses.",
		"run_as": "Execute the network scan in the Checkmk user context of the chosen user. This user needs the permission to add new hosts to this folder.",
		"scan_interval": "Scan interval in seconds. Default is 1 day, minimum is 1 hour.",
		"set_ip_address": "When set, the found IPv4 address is set on the discovered host.",
		"tag_criticality": "Specify which criticality tag to set on the host created by the network scan. This field is required if the criticality tag group exists, otherwise it as to be omitted.",
		"time_allowed": "Only execute the discovery during this time range each day..",
	},
	"NetworkScanResult": {
		"end": "When the scan finished. Will be Null if not yet run.",
		"output": "Short human readable description of what is happening.",
		"start": "When the scan started",
		"state": "Last scan result",
	},
	"NotExpr": {
		"expr": "The query expression to negate.",
		"op": "The operator. In this case `not`.",
	},
	"NotificationBulking": {
		"max_bulk_size": "At most that many Notifications are kept back for bulking. A value of 1 essentially turns off notification bulking.",
		"time_horizon": "Notifications are kept back for bulking at most for this time (seconds)",
	},
	"NotificationBulkingCommonAttributes": {
		"max_bulk_size": "At most that many Notifications are kept back for bulking. A value of 1 essentially turns off notification bulking.",
		"time_horizon": "Notifications are kept back for bulking at most for this time (seconds)",
	},
	"NotificationRuleResponse": {
		"domainType": "The domain type of the object.",
		"extensions": "The configuration attributes of a notification rule.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"NotificationRuleResponseCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of notification rule objects.",
	},
	"ObjectActionMember": {
		"disabledReason": "Provides the reason (or the literal \"disabled\") why an object property or collection is un-modifiable, or, in the case of an action, unusable (and hence no links to mutate that member's state, or invoke the action, are provided).",
		"invalidReason": "Provides the reason (or the literal \"invalid\") why a proposed value for a property, collection or action argument is invalid. Appears within an argument representation 2.9 returned as a response.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"x-ro-invalidReason": "Provides the reason why a SET OF proposed values for properties or arguments is invalid.",
	},
	"ObjectCollectionMember": {
		"disabledReason": "Provides the reason (or the literal \"disabled\") why an object property or collection is un-modifiable, or, in the case of an action, unusable (and hence no links to mutate that member's state, or invoke the action, are provided).",
		"invalidReason": "Provides the reason (or the literal \"invalid\") why a proposed value for a property, collection or action argument is invalid. Appears within an argument representation 2.9 returned as a response.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"x-ro-invalidReason": "Provides the reason why a SET OF proposed values for properties or arguments is invalid.",
	},
	"ObjectProperty": {
		"extensions": "Additional attributes alongside the property.",
		"id": "The unique name of this property, local to this domain type.",
		"links": "list of links to other resources.",
		"value": "The value of the property. In this case a list.",
	},
	"OpsGeniePluginCreate": {
		"actions": "Custom actions that will be available for the alert. You may paste a text from your clipboard which contains several parts separated by ';' characters into the last input field. The text will then be split by these separators and the single parts are added into dedicated input fields",
		"desc_for_host_alerts": "Description field of host alert that is generally used to provide a detailed information about the alert",
		"desc_for_service_alerts": "Description field of service alert that is generally used to provide a detailed information about the alert",
		"domain": "If you have an european account, please set the domain of your opsgenie. Specify an absolute URL like https://api.eu.opsgenie.com",
		"entity": "Is used to specify which domain the alert is related to",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"note_while_closing": "Additional note that will be added while closing the alert",
		"note_while_creating": "Additional note that will be added while creating the alert",
		"owner": "Sets the user of the alert. Display name of the request owner",
		"plugin_name": "The plugin name. Built-in plugins only.",
		"responsible_teams": "Team names which will be responsible for the alert. If the API Key belongs to a team integration, this field will be overwritten with the owner team. You may paste a text from your clipboard which contains several parts separated by ';' characters into the last input field. The text will then be ...",
		"source": "Source field of the alert. Default value is IP address of the incoming request",
		"tags": "Tags of the alert. You may paste a text from your clipboard which contains several parts separated by ';' characters into the last input field. The text will then be split by these separators and the single parts are added into dedicated input fields",
	},
	"OpsGenieStoreID": {
		"store_id": "A password store ID",
	},
	"PagerDutyAPIKeyStoreID": {
		"store_id": "A password store ID",
	},
	"PagerDutyPluginCreate": {
		"disable_ssl_cert_verification": "Ignore unverified HTTPS request warnings. Use with caution.",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"PasswordCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of password objects.",
	},
	"PasswordExtension": {
		"comment": "A comment for the password",
		"documentation_url": "The URL pointing to documentation or any other page.",
		"ident": "The unique identifier for the password",
		"owned_by": "The owner of the password who is able to edit, delete and use existing passwords.",
		"shared": "The list of members the password is shared with",
		"title": "The title for the password",
	},
	"PasswordObject": {
		"domainType": "The type of the domain-object.",
		"extensions": "All the attributes of the domain object.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"PendingChangesCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"links": "list of links to other resources.",
		"value": "The changes that are pending",
	},
	"PluginBase": {
		"option": "Create notifications with parameters or cancel previous notifications",
	},
	"PluginName": {
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"PluginWithParams": {
		"option": "Create notifications with parameters or cancel previous notifications",
	},
	"ProxyAttributes": {
		"global_settings": "When use_livestatus_daemon is set to 'with_proxy', you can set this to True to use global setting or False to use custom parameters.",
		"params": "The live status proxy daemon parameters.",
		"tcp": "Allow access via TCP configuration.",
		"use_livestatus_daemon": "Use livestatus daemon with direct connection or with livestatus proxy.",
	},
	"ProxyAttributes1": {
		"global_settings": "When Livestatus proxy daemon is set, you can enable this to use global setting and disable it to use custom parameters.",
		"params": "The live status proxy daemon parameters.",
		"tcp": "Allow access via TCP configuration.",
		"use_livestatus_daemon": "Use livestatus daemon with direct connection or with livestatus proxy.",
	},
	"ProxyParams": {
		"cache": "Enable caching.",
		"channel_timeout": "The timeout waiting for a free channel.",
		"channels": "The number of channels to keep open.",
		"connect_retry": "The cooling period after failed connect/heartbeat.",
		"heartbeat": "The heartbeat interval and timeout configuration.",
		"query_timeout": "The total query timeout.",
	},
	"ProxyParams1": {
		"cache": "Enable caching.",
		"channel_timeout": "The timeout waiting for a free channel.",
		"channels": "The number of channels to keep open.",
		"connect_retry": "The cooling period after failed connect/heartbeat.",
		"heartbeat": "The heartbeat interval and timeout configuration.",
		"query_timeout": "The total query timeout.",
	},
	"ProxyTcp": {
		"only_from": "Restrict access to these IP addresses.",
		"port": "The TCP port to connect to.",
		"tls": "Encrypt TCP Livestatus connections.",
	},
	"ProxyTcp1": {
		"only_from": "Restrict access to these IP addresses.",
		"port": "The livestatus proxy TCP port.",
		"tls": "Encrypt TCP Livestatus connections.",
	},
	"PushOverPluginCreate": {
		"api_key": "You need to provide a valid API key to be able to send push notifications using Pushover. Register and login to Pushover, thn create your Check_MK installation as application and obtain your API key",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"plugin_name": "The plugin name. Built-in plugins only.",
		"url_prefix_for_links_to_checkmk": "If you specify an URL prefix here, then several parts of the email body are armed with hyperlinks to your Check_MK GUI, so that the recipient of the email can directly visit the host or service in question in Check_MK. Specify an absolute URL including the .../check_mk/",
		"user_group_key": "Configure the user or group to receive the notifications by providing the user or group key here. The key can be obtained from the Pushover website.",
	},
	"RegexpRewrites": {
		"replace_with": "The replacement string. Match-groups can only be identified by `\\1`, `\\2`, etc. Highest supported match group is `\\99`. Named lookups are not supported.",
		"search": "The search regexp. May contain match-groups, conditional matches, etc. This follows the Python regular expression syntax. For details see: * https://docs.python.org/3/library/re.html",
	},
	"RegisterHost": {
		"uuid": "A valid UUID.",
	},
	"RenameHost": {
		"new_name": "The new name of the existing host.",
	},
	"RuleCollection": {
		"domainType": "Domain type of this object.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "The collection itself. Each entry in here is part of the collection.",
	},
	"RuleConditions1": {
		"host_labels": "Further restrict this rule by applying host label conditions.",
		"host_name": "Here you can enter a list of explicit host names that the rule should or should not apply to. Leave this option disabled if you want the rule to apply for all hosts specified by the given tags. The names that you enter here are compared with case sensitive exact matching. Alternatively you can us...",
		"host_tags": "The rule will only be applied to hosts fulfilling all the host tag conditions listed here, even if they appear in the list of explicit host names.",
		"service_description": "Specify a list of service patterns this rule shall apply to. * The patterns must match the beginning of the service in question. * Adding a `$` to the end forces an exact match. * Pattern use regular expressions. e.g. a `.*` will match an arbitrary text. * The text entered here is handled as a re...",
		"service_labels": "Restrict the application of the rule, by checking against service label conditions.",
	},
	"RuleExtensions": {
		"conditions": "Conditions.",
		"folder": "The path name of the folder. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"folder_index": "The position of this rule in the chain in this folder.",
		"properties": "Property values of this rule.",
		"ruleset": "The name of the ruleset.",
		"value_raw": "The raw parameter value for this rule.",
	},
	"RuleObject": {
		"domainType": "Domain type of this object.",
		"extensions": "Attributes specific to rule objects.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"RuleProperties": {
		"allow_users_to_deactivate": "If you set this option then users are allowed to deactivate notifications that are created by this rule.",
		"comment": "An optional comment that may be used to explain the purpose of this object.",
		"description": "A description or title of this rule.",
		"do_not_apply_this_rule": "Disabled rules are kept in the configuration but are not applied.",
		"documentation_url": "An optional URL pointing to documentation or any other page. This will be displayed as an icon and open a new page when clicked.",
	},
	"RuleProperties1": {
		"comment": "Any comment string.",
		"description": "A description for this rule to inform other users about its intent.",
		"disabled": "When set to False, the rule will be evaluated. Default is False.",
		"documentation_url": "An URL (e.g. an internal Wiki entry) which explains this rule.",
	},
	"RulePropertiesAttributes": {
		"allow_users_to_deactivate": "If you set this option then users are allowed to deactivate notifications that are created by this rule.",
		"comment": "An optional comment that may be used to explain the purpose of this object.",
		"description": "A description or title of this rule.",
		"do_not_apply_this_rule": "Disabled rules are kept in the configuration but are not applied.",
		"documentation_url": "An optional URL pointing to documentation or any other page. This will be displayed as an icon and open a new page when clicked.",
	},
	"RulesetCollection": {
		"domainType": "Domain type of this object.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "The collection itself. Each entry in here is part of the collection.",
	},
	"RulesetExtensions": {
		"folder": "The path name of the folder. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"name": "The name of the ruleset",
		"number_of_rules": "The number of rules of this ruleset.",
	},
	"RulesetObject": {
		"domainType": "Domain type of this object.",
		"extensions": "Specific attributes related to rulesets.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"SMSAPIPStoreID": {
		"store_id": "A password store ID",
	},
	"SMSAPIPluginCreate": {
		"disable_ssl_cert_verification": "Ignore unverified HTTPS request warnings. Use with caution.",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"modem_type": "Choose what modem is used. Currently supported is only Teltonika-TRB140.",
		"modem_url": "Configure your modem URL here",
		"plugin_name": "The plugin name. Built-in plugins only.",
		"timeout": "Here you can configure timeout settings",
		"username": "Configure the user name here",
	},
	"SMSPluginBase": {
		"params": "The given parameters are available in scripts as NOTIFY_PARAMETER_1, NOTIFY_PARAMETER_2, etc. You may paste a text from your clipboard which contains several parts separated by ';' characters into the last input field. The text will then be split by these separators and the single parts are added...",
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"SNMPCommunity": {
		"community": "SNMP community (SNMP Versions 1 and 2c)",
	},
	"SNMPv3AuthNoPrivacy": {
		"auth_password": "Authentication pass phrase.",
		"auth_protocol": "Authentication protocol.",
		"security_name": "Security name",
		"type": "The type of credentials to use.",
	},
	"SNMPv3AuthPrivacy": {
		"auth_password": "Authentication pass phrase.",
		"auth_protocol": "Authentication protocol.",
		"privacy_password": "Privacy pass phrase. If filled, privacy_protocol needs to be selected as well.",
		"privacy_protocol": "The privacy protocol. The only supported values in the Raw Edition are CBC-DES and AES-128. If selected, privacy_password needs to be supplied as well.",
		"security_name": "Security name",
		"type": "SNMPv3 with authentication and privacy.",
	},
	"SNMPv3NoAuthNoPrivacy": {
		"security_name": "Security name",
		"type": "The type of credentials to use.",
	},
	"ServiceGroup": {
		"domainType": "The domain type of the object.",
		"extensions": "All the attributes of the domain object.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"ServiceGroupCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of service group objects.",
	},
	"ServiceGroupsRegex": {
		"regex_list": "The text entered in this list is handled as a regular expression pattern",
	},
	"ServiceNowPasswordStoreID": {
		"store_id": "A password store ID",
	},
	"ServiceNowPluginCreate": {
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"plugin_name": "The plugin name. Built-in plugins only.",
		"servicenow_url": "Configure your ServiceNow URL here",
		"username": "Configure the user name here",
	},
	"SignL4TeamSecretStoreID": {
		"store_id": "A password store ID",
	},
	"Signl4PluginCreate": {
		"disable_ssl_cert_verification": "Ignore unverified HTTPS request warnings. Use with caution.",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"SiteConfigAttributes": {
		"secret": "The shared secret used by the central site to authenticate with the remote site for configuring Checkmk.",
	},
	"SiteConfigAttributesCreate": {
		"secret": "The shared secret used by the central site to authenticate with the remote site for configuring Checkmk.",
	},
	"SiteConfigAttributesUpdate": {
		"secret": "The shared secret used by the central site to authenticate with the remote site for configuring Checkmk.",
	},
	"SiteConnectionRequestCreate": {
		"site_config": "A site's connection.",
	},
	"SiteConnectionRequestUpdate": {
		"site_config": "A site's connection.",
	},
	"SiteConnectionResponse": {
		"domainType": "The domain type of the object.",
		"extensions": "The configuration attributes of a site.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"SiteConnectionResponseCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of site configuration objects.",
	},
	"SiteLoginRequest": {
		"password": "The password for the username given",
		"username": "An administrative user's username.",
	},
	"SlackPluginCreate": {
		"disable_ssl_cert_verification": "Ignore unverified HTTPS request warnings. Use with caution.",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"SlackWebhookStore": {
		"store_id": "A password store ID",
	},
	"SocketAttributes1": {
		"encrypted": "To enable an encrypted connection.",
		"host": "The IP or domain name of the host.",
		"path": "When the connection name is unix, this is the path to the unix socket.",
		"port": "The TCP port to connect to.",
		"socket_type": "The connection name. This can be tcp, tcp6, unix or local.",
		"verify": "Verify server certificate.",
	},
	"SocketIP4": {
		"encrypted": "To enable an encrypted connection.",
		"host": "The IP or domain name of the host.",
		"port": "The TCP port to connect to.",
		"socket_type": "The connection name. This can be tcp, tcp6, unix or local.",
		"verify": "Verify server certificate.",
	},
	"SocketIP6": {
		"encrypted": "To enable an encrypted connection.",
		"host": "The IP or domain name of the host.",
		"port": "The TCP port to connect to.",
		"socket_type": "The connection name. This can be tcp, tcp6, unix or local.",
		"verify": "Verify server certificate.",
	},
	"SocketType": {
		"socket_type": "The connection name. This can be tcp, tcp6, unix or local.",
	},
	"SocketUnixAttributes": {
		"path": "When the connection name is unix, this is the path to the unix socket.",
		"socket_type": "The connection name. This can be tcp, tcp6, unix or local.",
	},
	"SpectrumPluginBase": {
		"base_oid": "The base OID for the trap content",
		"destination_ip": "IP Address of the Spectrum server receiving the SNMP trap",
		"plugin_name": "The plugin name. Built-in plugins only.",
		"snmp_community": "SNMP Community for the SNMP trap. The password entered here is stored in plain text within the monitoring site. This usually needed because the monitoring process needs to have access to the unencrypted password because it needs to submit it to authenticate with remote systems",
	},
	"SplunkStoreID": {
		"store_id": "A password store ID",
	},
	"SplunkURLExplicit": {
		"url": "A valid splunk webhook URL",
	},
	"StatusConnectionAttributes": {
		"connect_timeout": "The time that the GUI waits for a connection to the site to be established before the site is considered to be unreachable.",
		"connection": "When connecting to remote site please make sure that Livestatus over TCP is activated there. You can use UNIX sockets to connect to foreign sites on localhost.",
		"disable_in_status_gui": "If you disable a connection, then no data of this site will be shown in the status GUI. The replication is not affected by this, however.",
		"persistent_connection": "If you enable persistent connections then Multisite will try to keep open the connection to the remote sites.",
		"proxy": "The Livestatus proxy daemon configuration attributes.",
		"status_host": "By specifying a status host for each non-local connection you prevent Multisite from running into timeouts when remote sites do not respond.",
		"url_prefix": "The URL prefix will be prepended to links of addons like NagVis when a link to such applications points to a host or service on that site.",
	},
	"StatusConnectionAttributes1": {
		"connect_timeout": "The time that the GUI waits for a connection to the site to be established before the site is considered to be unreachable.",
		"connection": "When connecting to remote site please make sure that Livestatus over TCP is activated there. You can use UNIX sockets to connect to foreign sites on localhost.",
		"disable_in_status_gui": "If you disable a connection, then no data of this site will be shown in the status GUI. The replication is not affected by this, however.",
		"persistent_connection": "If you enable persistent connections then Multisite will try to keep open the connection to the remote sites.",
		"proxy": "The Livestatus proxy daemon configuration attributes.",
		"status_host": "By specifying a status host for each non-local connection you prevent Multisite from running into timeouts when remote sites do not respond.",
		"url_prefix": "The URL prefix will be prepended to links of addons like NagVis when a link to such applications points to a host or service on that site.",
	},
	"StatusHostAttributes": {
		"host": "The host name of the status host.",
		"site": "The site ID of the status host.",
		"status_host_set": "enabled for 'use the following status host' and disabled for 'no status host'.",
	},
	"StatusHostAttributesBase": {
		"status_host_set": "enabled for 'use the following status host' and disabled for 'no status host'",
	},
	"StatusHostAttributesSet": {
		"host": "The host name of the status host.",
		"site": "The site ID of the status host.",
		"status_host_set": "enabled for 'use the following status host' and disabled for 'no status host'",
	},
	"TagConditionConditionSchemaBase": {
		"key": "The name of the tag.",
		"operator": "If the matched tag should be one of the given values, or not.",
		"value": "A list of values for the tag.",
	},
	"TagConditionScalarSchemaBase": {
		"key": "The name of the tag.",
		"operator": "If the tag's value should match what is given under the field `value`.",
		"value": "The value of a tag.",
	},
	"ThrottlePeriodicNotifications": {
		"beginning_from": "Beginning notification number",
		"send_every_nth_notification": "The rate then you will receive the notification 1 through 10 and then 15, 20, 25... and so on",
	},
	"TimeAllowedRange": {
		"end": "The end time of day. Inclusive. Use ISO8601 format. Seconds are stripped.",
		"start": "The start time of day. Inclusive. Use ISO8601 format. Seconds are stripped.",
	},
	"TimePeriodAttrsResponse": {
		"active_time_ranges": "The days for which time ranges were specified",
		"alias": "The alias of the time period",
		"exceptions": "Specific day exclusions with their list of time ranges",
		"exclude": "The collection of time period aliases whose periods are excluded",
	},
	"TimePeriodException": {
		"date": "The date of the time period exception.8601 profile",
	},
	"TimePeriodResponse": {
		"domainType": "The domain type of the object.",
		"extensions": "The time period attributes.",
		"id": "The unique identifier for this time period.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "The time period name.",
	},
	"TimePeriodResponseCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of time period objects.",
	},
	"TimeRange": {
		"end": "The approximate time of the last sample.",
		"start": "The approximate time of the first sample.",
	},
	"TimeRange1": {
		"end": "The end time of the period's time range",
		"start": "The start time of the period's time range",
	},
	"TimeRangeActive": {
		"day": "The day for which time ranges are to be specified. The 'all' option allows to specify time ranges for all days.",
	},
	"TranslateNames": {
		"convert_case": "Convert all detected hostnames to upper- or lower-case. * `nop` - Do not convert anything * `lower` - Convert all hostnames to lowercase. * `upper` - Convert all hostnames to uppercase.",
		"drop_domain": "Drop the rest of the domain, only keep the hostname. Will not affect IP addresses. Examples: * `192.168.0.1` -> `192.168.0.1` * `foobar.example.com` -> `foobar` * `example.com` -> `example` * `example` -> `example` This will be executed **after**: * `convert_case`",
		"hostname_replacement": "Replace one value with another. These will be executed **after**: * `convert_case` * `drop_domain` * `regexp_rewrites`",
		"regexp_rewrites": "Rewrite discovered hostnames with multiple regular expressions. The replacements will be done one after another in the order they appear in the list. If not anchored at the end by a `$` character, the regexpwill be anchored at the end implicitly by adding a `$` character. These will be executed *...",
	},
	"UpdateAndAcknowledgeEvent": {
		"change_comment": "Event comment.",
		"change_contact": "Contact information.",
		"phase": "To change the phase of an event",
	},
	"UpdateAndAcknowledgeFilter": {
		"change_comment": "Event comment.",
		"change_contact": "Contact information.",
		"filter_type": "The way you would like to filter events.",
		"phase": "To change the phase of an event",
	},
	"UpdateAndAcknowledgeWithParams": {
		"change_comment": "Event comment.",
		"change_contact": "Contact information.",
		"filter_type": "The way you would like to filter events.",
		"phase": "To change the phase of an event",
	},
	"UpdateAndAcknowledgeWithQuery": {
		"change_comment": "Event comment.",
		"change_contact": "Contact information.",
		"filter_type": "The way you would like to filter events.",
		"phase": "To change the phase of an event",
		"query": "An query expression of the Livestatus 'eventconsoleevents' table in nested dictionary form. If you want to use multiple expressions, nest them with the AND/OR operators.",
	},
	"UpdateContactGroup": {
		"name": "The name of the contact group.",
	},
	"UpdateDiscoveryPhase": {
		"check_type": "The name of the check which this service uses.",
		"service_item": "The value uniquely identifying the service on a given host.",
		"target_phase": "The target phase of the service.",
	},
	"UpdateFolder": {
		"attributes": "Replace all attributes with the ones given in this field. Already setattributes, not given here, will be removed.",
		"title": "The title of the folder. Used in the GUI.",
	},
	"UpdateFolderEntry": {
		"attributes": "Replace all attributes with the ones given in this field. Already setattributes, not given here, will be removed.",
		"folder": "The path name of the folder. Path delimiters can be either `~`, `/` or `\\`. Please use the one most appropriate for your quoting/escaping needs. A good default choice is `~`.",
		"title": "The title of the folder. Used in the GUI.",
	},
	"UpdateGroup": {
		"alias": "The name used for displaying in the GUI.",
	},
	"UpdateGroup1": {
		"alias": "The name used for displaying in the GUI.",
	},
	"UpdateGroup2": {
		"alias": "The name used for displaying in the GUI.",
	},
	"UpdateHost": {
		"attributes": "Replace all currently set attributes on the host, with these attributes. Any previously set attributes which are not given here will be removed.",
	},
	"UpdateHostEntry": {
		"attributes": "Replace all currently set attributes on the host, with these attributes. Any previously set attributes which are not given here will be removed.",
		"host_name": "The hostname or IP address itself.",
	},
	"UpdateHostGroup": {
		"name": "The name of the host group.",
	},
	"UpdateHostTagGroup": {
		"help": "A help description for the tag group",
		"repair": "The host tag group can be in use by other hosts. Setting repair to True gives permission to automatically update the tag from the affected hosts.",
		"tags": "A list of host tags belonging to the host tag group",
		"title": "A title for the host tag",
		"topic": "Different tags can be grouped in a topic",
	},
	"UpdateNodes": {
		"nodes": "Nodes where the newly created host should be the cluster-container of.",
	},
	"UpdatePassword": {
		"comment": "A comment for the password",
		"documentation_url": "An optional URL pointing to documentation or any other page. You can use either global URLs (beginning with http://), absolute local urls (beginning with /) or relative URLs (that are relative to check_mk/).",
		"owner": "Each password is owned by a group of users which are able to edit, delete and use existing passwords.",
		"password": "The password string",
		"shared": "The list of members to share the password with",
		"title": "A title for the password",
	},
	"UpdateServiceGroup": {
		"name": "The name of the service group.",
	},
	"UpdateTimePeriod": {
		"active_time_ranges": "The list of active time ranges which replaces the existing list of time ranges",
		"alias": "An alias for the time period",
		"exceptions": "A list of additional time ranges to be added.",
	},
	"UpdateUser": {
		"auth_option": "Authentication option for the user",
		"authorized_sites": "The names of the sites the user is authorized to handle. Specifying 'all' will grant the user access to all sites.",
		"contact_options": "Contact settings for the user",
		"contactgroups": "Assign the user to one or multiple contact groups. If no contact group is specified then no monitoring contact will be created for the user.",
		"disable_login": "The user can be blocked from login but will remain part of the site. The disabling does not affect notification and alerts.",
		"fullname": "The alias or full name of the user",
		"idle_timeout": "Idle timeout for the user",
		"language": "Configure the language to be used by the user in the user interface. Omitting this will configure the default language",
		"roles": "The list of assigned roles to the user",
		"temperature_unit": "Configure the temperature unit used for graphs and perfometers.",
	},
	"UseLiveStatusDaemon": {
		"use_livestatus_daemon": "Use livestatus daemon with direct connection or with livestatus proxy.",
	},
	"UserCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of user objects.",
	},
	"UserContactOption": {
		"email": "The mail address of the user. Required if the user is a monitoringcontact and receives notifications via mail.",
		"fallback_contact": "In case none of your notification rules handles a certain event a notification will be sent to the specified email",
	},
	"UserIdleOption": {
		"duration": "The duration in seconds of the individual idle timeout if individual is selected as idle timeout option.",
		"option": "This field indicates if the idle timeout uses the global configuration, is disabled or uses an individual duration",
	},
	"UserInterfaceAttributes": {
		"interface_theme": "The theme of the interface",
		"mega_menu_icons": "This option decides if colored icon should be shown foe every entry in the mega menus or alternatively only for the headlines (the 'topics')",
		"navigation_bar_icons": "This option decides if icons in the navigation bar should show/hide the respective titles",
		"show_mode": "This option decides what show mode should be used for unvisited menus. Alternatively, this option can also be used to enforce show more removing the three dots for all menus.",
		"sidebar_position": "The position of the sidebar",
	},
	"UserInterfaceUpdateAttributes": {
		"interface_theme": "The theme of the interface",
		"mega_menu_icons": "This option decides if colored icon should be shown foe every entry in the mega menus or alternatively only for the headlines (the 'topics')",
		"navigation_bar_icons": "This option decides if icons in the navigation bar should show/hide the respective titles",
		"show_mode": "This option decides what show mode should be used for unvisited menus. Alternatively, this option can also be used to enforce show more removing the three dots for all menus.",
		"sidebar_position": "The position of the sidebar",
	},
	"UserObject": {
		"domainType": "The domain type of the object.",
		"extensions": "The attributes of the user",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"UserRoleAttributes": {
		"alias": "The alias of the user role.",
		"basedon": "The builtin user role id that the user role is based on.",
		"builtin": "True if it's a builtin user role, otherwise False.",
		"permissions": "A list of permissions for the user role.",
	},
	"UserRoleCollection": {
		"domainType": "The domain type of the objects in the collection.",
		"extensions": "Additional attributes alongside the collection.",
		"id": "The name of this collection.",
		"links": "list of links to other resources.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
		"value": "A list of user role objects.",
	},
	"UserRoleObject": {
		"domainType": "The domain type of the object.",
		"extensions": "All the attributes of a user role.",
		"id": "The unique identifier for this domain-object type.",
		"links": "list of links to other resources.",
		"members": "The container for external resources, like linked foreign objects or actions.",
		"title": "A human readable title of this object. Can be used for user interfaces.",
	},
	"UserSyncAttributes1": {
		"ldap_connections": "A list of ldap connections.",
		"sync_with_ldap_connections": "Sync with ldap connections. The options are ldap, all, disabled.",
	},
	"UserSyncBase": {
		"sync_with_ldap_connections": "Sync with ldap connections. The options are ldap, all, disabled.",
	},
	"UserSyncWithLdapConnection": {
		"ldap_connections": "A list of ldap connections.",
		"sync_with_ldap_connections": "Sync with ldap connections. The options are ldap, all, disabled.",
	},
	"VictoropsPluginCreate": {
		"disable_ssl_cert_verification": "Ignore unverified HTTPS request warnings. Use with caution.",
		"http_proxy": "Use the proxy settings from the environment variables. The variables NO_PROXY, HTTP_PROXY and HTTPS_PROXY are taken into account during execution.",
		"plugin_name": "The plugin name. Built-in plugins only.",
	},
	"WhenToBulk": {
		"when_to_bulk": "Bulking can always happen or during a set time period",
	},
	"X509PEM": {
		"cert": "PEM-encoded X.509 certificate.",
	},
	"X509ReqPEMUUID": {
		"csr": "PEM-encoded X.509 CSR. The CN must a valid version-4 UUID.",
	},
}

// FieldTypes maps schema names to field OpenAPI types.
// Use for type coercion and validation.
var FieldTypes = map[string]map[string]string{
	"AcknowledgeHostGroupProblem": {
		"acknowledge_type": "string",
		"comment": "string",
		"hostgroup_name": "string",
		"notify": "boolean",
		"persistent": "boolean",
		"sticky": "boolean",
	},
	"AcknowledgeHostProblem": {
		"acknowledge_type": "string",
		"comment": "string",
		"host_name": "string",
		"notify": "boolean",
		"persistent": "boolean",
		"sticky": "boolean",
	},
	"AcknowledgeHostQueryProblem": {
		"acknowledge_type": "string",
		"comment": "string",
		"notify": "boolean",
		"persistent": "boolean",
		"query": "",
		"sticky": "boolean",
	},
	"AcknowledgeServiceGroupProblem": {
		"acknowledge_type": "string",
		"comment": "string",
		"notify": "boolean",
		"persistent": "boolean",
		"servicegroup_name": "string",
		"sticky": "boolean",
	},
	"AcknowledgeServiceQueryProblem": {
		"acknowledge_type": "string",
		"comment": "string",
		"notify": "boolean",
		"persistent": "boolean",
		"query": "",
		"sticky": "boolean",
	},
	"AcknowledgeSpecificServiceProblem": {
		"acknowledge_type": "string",
		"comment": "string",
		"host_name": "string",
		"notify": "boolean",
		"persistent": "boolean",
		"service_description": "string",
		"sticky": "boolean",
	},
	"ActivateChanges": {
		"force_foreign_changes": "boolean",
		"redirect": "boolean",
		"sites": "array",
	},
	"ActivationExtensionFields": {
		"changes": "array",
		"force_foreign_changes": "boolean",
		"is_running": "boolean",
		"sites": "array",
		"time_started": "string",
	},
	"ActivationRunCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"value": "array",
	},
	"ActivationRunResponse": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"AgentControllerCertificateSettings": {
		"lifetime_in_months": "integer",
	},
	"ApiError": {
		"detail": "string",
		"ext": "object",
		"fields": "object",
		"status": "integer",
		"title": "string",
	},
	"AsciiMailPluginCreate": {
		"body_head_for_both_host_and_service_notifications": "object",
		"body_tail_for_host_notifications": "object",
		"body_tail_for_service_notifications": "object",
		"from_details": "object",
		"plugin_name": "string",
		"reply_to": "object",
		"send_separate_notification_to_every_recipient": "object",
		"sort_order_for_bulk_notificaions": "object",
		"subject_for_host_notifications": "object",
		"subject_for_service_notifications": "object",
	},
	"AuthOption1": {
		"auth_type": "string",
		"enforce_password_change": "boolean",
	},
	"AuthPassword": {
		"auth_type": "string",
		"enforce_password_change": "boolean",
		"password": "string",
	},
	"AuthSecret": {
		"auth_type": "string",
		"secret": "string",
	},
	"AuthUpdatePassword": {
		"auth_type": "string",
		"enforce_password_change": "boolean",
		"password": "string",
	},
	"AuthUpdateRemove": {
		"auth_type": "string",
	},
	"AuthUpdateSecret": {
		"auth_type": "string",
		"secret": "string",
	},
	"AuxTagAttrsCreate": {
		"aux_tag_id": "string",
		"help": "string",
		"title": "string",
		"topic": "string",
	},
	"AuxTagAttrsResponse": {
		"help": "string",
		"topic": "string",
	},
	"AuxTagAttrsUpdate": {
		"help": "string",
		"title": "string",
		"topic": "string",
	},
	"AuxTagResponse": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"AuxTagResponseCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"BIAggregationComputationOptions": {
		"disabled": "boolean",
		"escalate_downtimes_as_warn": "boolean",
		"freeze_aggregations": "boolean",
		"use_hard_states": "boolean",
	},
	"BIAggregationEndpoint": {
		"aggregation_visualization": "",
		"comment": "string",
		"computation_options": "",
		"customer": "string",
		"groups": "",
		"id": "string",
		"node": "",
		"pack_id": "string",
	},
	"BIAggregationFunctionBest": {
		"count": "integer",
		"restrict_state": "integer",
		"type": "",
	},
	"BIAggregationFunctionCountOK": {
		"levels_ok": "object",
		"levels_warn": "object",
		"type": "",
	},
	"BIAggregationFunctionCountSettings": {
		"type": "string",
		"value": "integer",
	},
	"BIAggregationFunctionWorst": {
		"count": "integer",
		"restrict_state": "integer",
		"type": "",
	},
	"BIAggregationGroups": {
		"names": "array",
		"paths": "array",
	},
	"BIAggregationStateRequest": {
		"filter_groups": "array",
		"filter_names": "array",
	},
	"BIAggregationStateResponse": {
		"aggregations": "object",
		"missing_aggr": "array",
		"missing_sites": "array",
	},
	"BIAggregationVisualization": {
		"ignore_rule_styles": "boolean",
		"layout_id": "string",
		"line_style": "string",
	},
	"BIAllHostsChoice": {
		"type": "",
	},
	"BICallARuleAction": {
		"params": "",
		"rule_id": "string",
		"type": "",
	},
	"BIEmptySearch": {
		"type": "",
	},
	"BIFixedArgumentsSearch": {
		"arguments": "array",
		"type": "",
	},
	"BIFixedArgumentsSearchToken": {
		"key": "string",
		"values": "array",
	},
	"BIHostAliasRegexChoice": {
		"pattern": "string",
		"type": "",
	},
	"BIHostNameRegexChoice": {
		"pattern": "string",
		"type": "",
	},
	"BIHostSearch": {
		"conditions": "object",
		"refer_to": "object",
		"type": "",
	},
	"BINodeGenerator": {
		"action": "",
		"search": "",
	},
	"BINodeVisBlockStyle": {
		"style_config": "",
		"type": "",
	},
	"BINodeVisForceStyle": {
		"style_config": "",
		"type": "",
	},
	"BINodeVisHierarchyStyle": {
		"style_config": "object",
		"type": "",
	},
	"BINodeVisHierarchyStyleConfig": {
		"layer_height": "integer",
		"node_size": "integer",
		"rotation": "integer",
	},
	"BINodeVisNoneStyle": {
		"style_config": "",
		"type": "",
	},
	"BINodeVisRadialStyle": {
		"style_config": "object",
		"type": "",
	},
	"BINodeVisRadialStyleConfig": {
		"degree": "integer",
		"radius": "integer",
		"rotation": "integer",
	},
	"BIPackEndpoint": {
		"contact_groups": "array",
		"public": "boolean",
		"title": "string",
	},
	"BIParams": {
		"arguments": "array",
	},
	"BIRuleComputationOptions": {
		"disabled": "boolean",
	},
	"BIRuleEndpoint": {
		"aggregation_function": "",
		"computation_options": "",
		"id": "string",
		"node_visualization": "",
		"nodes": "array",
		"pack_id": "string",
		"params": "",
		"properties": "",
	},
	"BIRuleProperties": {
		"comment": "string",
		"docu_url": "string",
		"icon": "string",
		"state_messages": "object",
		"title": "string",
	},
	"BIServiceSearch": {
		"conditions": "object",
		"type": "",
	},
	"BIStateOfHostAction": {
		"host_regex": "string",
		"type": "",
	},
	"BIStateOfRemainingServicesAction": {
		"host_regex": "string",
		"type": "",
	},
	"BIStateOfServiceAction": {
		"host_regex": "string",
		"service_regex": "string",
		"type": "",
	},
	"BackgroundJobStatus": {
		"active": "boolean",
		"logs": "",
		"state": "string",
	},
	"BaseUserAttributes": {
		"auth_option": "",
		"authorized_sites": "array",
		"contact_options": "",
		"contactgroups": "array",
		"disable_login": "boolean",
		"disable_notifications": "object",
		"fullname": "string",
		"idle_timeout": "",
		"interface_options": "object",
		"language": "string",
		"pager_address": "string",
		"roles": "array",
		"temperature_unit": "string",
	},
	"BasicSettingsAttributes": {
		"alias": "string",
		"site_id": "string",
	},
	"BasicSettingsAttributesCreate": {
		"alias": "string",
		"site_id": "string",
	},
	"BasicSettingsAttributesUpdate": {
		"alias": "string",
		"site_id": "string",
	},
	"BinaryExpr": {
		"left": "string",
		"op": "string",
		"right": "string",
	},
	"BulkCreateHost": {
		"entries": "array",
	},
	"BulkDeleteContactGroup": {
		"entries": "array",
	},
	"BulkDeleteHost": {
		"entries": "array",
	},
	"BulkDeleteHostGroup": {
		"entries": "array",
	},
	"BulkDeleteServiceGroup": {
		"entries": "array",
	},
	"BulkDiscovery": {
		"bulk_size": "integer",
		"do_full_scan": "boolean",
		"hostnames": "array",
		"ignore_errors": "boolean",
		"mode": "string",
	},
	"BulkHostActionWithFailedHosts": {
		"detail": "string",
		"ext": "",
		"fields": "object",
		"status": "integer",
		"title": "string",
	},
	"BulkInputContactGroup": {
		"entries": "array",
	},
	"BulkInputHostGroup": {
		"entries": "array",
	},
	"BulkInputServiceGroup": {
		"entries": "array",
	},
	"BulkOutsideTimePeriodValue": {
		"state": "string",
		"value": "object",
	},
	"BulkUpdateContactGroup": {
		"entries": "array",
	},
	"BulkUpdateFolder": {
		"entries": "array",
	},
	"BulkUpdateHost": {
		"entries": "array",
	},
	"BulkUpdateHostGroup": {
		"entries": "array",
	},
	"BulkUpdateServiceGroup": {
		"entries": "array",
	},
	"CaseParams": {
		"host_description": "object",
		"host_short_description": "object",
		"priority": "object",
		"service_description": "object",
		"service_short_description": "object",
		"state_recovery": "object",
	},
	"ChangeEventState": {
		"new_state": "string",
	},
	"ChangeStateWithParams": {
		"filter_type": "string",
		"filters": "object",
		"new_state": "string",
	},
	"ChangeStateWithQuery": {
		"filter_type": "string",
		"new_state": "string",
		"query": "",
	},
	"ChangesFields": {
		"action_name": "string",
		"id": "string",
		"text": "string",
		"time": "string",
		"user_id": "string",
	},
	"Checkbox": {
		"state": "string",
	},
	"CheckboxHostEventType": {
		"state": "string",
		"value": "",
	},
	"CheckboxLabel": {
		"key": "string",
		"value": "string",
	},
	"CheckboxMatchHostTags": {
		"state": "string",
		"value": "",
	},
	"CheckboxRestrictNotificationNumbers": {
		"state": "string",
		"value": "object",
	},
	"CheckboxServiceEventType": {
		"state": "string",
		"value": "",
	},
	"CheckboxThrottlePeriodicNotifcations": {
		"state": "string",
		"value": "object",
	},
	"CheckboxWithFromToServiceLevels": {
		"state": "string",
		"value": "",
	},
	"CheckboxWithListOfLabels": {
		"state": "string",
		"value": "array",
	},
	"CheckboxWithListOfServiceGroupsRegex": {
		"state": "string",
		"value": "",
	},
	"CheckboxWithListOfStr": {
		"state": "string",
		"value": "array",
	},
	"CheckboxWithStr": {
		"state": "string",
		"value": "string",
	},
	"CheckboxWithStrValue": {
		"state": "string",
		"value": "string",
	},
	"CheckboxWithSysLogPriority": {
		"state": "string",
		"value": "object",
	},
	"Child": {
		"type": "",
	},
	"ChildWith": {
		"conditions": "object",
		"host_choice": "",
	},
	"CiscoExplicitWebhookUrl": {
		"option": "string",
		"url": "string",
	},
	"CiscoPasswordStore": {
		"option": "string",
		"store_id": "string",
	},
	"CiscoWebexPluginCreate": {
		"disable_ssl_cert_verification": "",
		"http_proxy": "",
		"plugin_name": "string",
		"url_prefix_for_links_to_checkmk": "object",
		"webhook_url": "object",
	},
	"ClusterCreateAttribute": {
		"additional_ipv4addresses": "array",
		"additional_ipv6addresses": "array",
		"alias": "string",
		"contactgroups": "",
		"inventory_failed": "boolean",
		"ipaddress": "string",
		"ipv6address": "string",
		"labels": "object",
		"locked_attributes": "array",
		"locked_by": "",
		"management_address": "string",
		"management_ipmi_credentials": "",
		"management_protocol": "string",
		"management_snmp_community": "",
		"network_scan": "",
		"parents": "array",
		"site": "string",
		"snmp_community": "",
		"tag_address_family": "string",
		"tag_agent": "string",
		"tag_criticality": "string",
		"tag_networking": "string",
		"tag_piggyback": "string",
		"tag_snmp_ds": "string",
	},
	"CommentAttributes": {
		"author": "string",
		"comment": "string",
		"entry_time": "string",
		"host_name": "string",
		"id": "integer",
		"is_service": "boolean",
		"persistent": "boolean",
		"service_description": "string",
	},
	"CommentCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"CommentObject": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"ConcreteDisabledNotifications": {
		"disable": "boolean",
		"timerange": "",
	},
	"ConcreteHostTagGroup": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"ConcreteTimePeriodException": {
		"date": "string",
		"time_ranges": "array",
	},
	"ConcreteTimeRange": {
		"end": "string",
		"start": "string",
	},
	"ConcreteTimeRangeActive": {
		"day": "string",
		"time_ranges": "array",
	},
	"ConcreteUserContactOption": {
		"email": "string",
		"fallback_contact": "boolean",
	},
	"ConcreteUserInterfaceAttributes": {
		"interface_theme": "string",
		"mega_menu_icons": "string",
		"navigation_bar_icons": "string",
		"show_mode": "string",
		"sidebar_position": "string",
	},
	"ConditionsAttributes": {
		"event_console_alerts": "object",
		"match_check_types": "object",
		"match_contact_groups": "object",
		"match_exclude_hosts": "object",
		"match_exclude_service_groups": "object",
		"match_exclude_service_groups_regex": "object",
		"match_exclude_services": "object",
		"match_folder": "object",
		"match_host_event_type": "object",
		"match_host_groups": "object",
		"match_host_labels": "object",
		"match_host_tags": "object",
		"match_hosts": "object",
		"match_notification_comment": "object",
		"match_only_during_time_period": "object",
		"match_plugin_output": "object",
		"match_service_event_type": "object",
		"match_service_groups": "object",
		"match_service_groups_regex": "object",
		"match_service_labels": "object",
		"match_service_levels": "object",
		"match_services": "object",
		"match_sites": "object",
		"restrict_to_notification_numbers": "object",
		"throttle_periodic_notifications": "object",
	},
	"ConfigurationConnectionAttributes": {
		"direct_login_to_web_gui_allowed": "boolean",
		"disable_remote_configuration": "boolean",
		"enable_replication": "boolean",
		"ignore_tls_errors": "boolean",
		"replicate_event_console": "boolean",
		"replicate_extensions": "boolean",
		"url_of_remote_site": "string",
		"user_sync": "",
	},
	"ConfigurationConnectionAttributes1": {
		"direct_login_to_web_gui_allowed": "boolean",
		"disable_remote_configuration": "boolean",
		"enable_replication": "boolean",
		"ignore_tls_errors": "boolean",
		"replicate_event_console": "boolean",
		"replicate_extensions": "boolean",
		"url_of_remote_site": "string",
		"user_sync": "",
	},
	"ConnectionMode": {
		"connection_mode": "string",
	},
	"ContactGroup": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"ContactGroupCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"ContactSelection": {
		"all_contacts_of_the_notified_object": "object",
		"all_users": "object",
		"all_users_with_an_email_address": "object",
		"explicit_email_addresses": "object",
		"members_of_contact_groups": "object",
		"restrict_by_contact_groups": "object",
		"restrict_by_custom_macros": "object",
		"the_following_users": "object",
	},
	"ContactSelectionAttributes": {
		"all_contacts_of_the_notified_object": "object",
		"all_users": "object",
		"all_users_with_an_email_address": "object",
		"explicit_email_addresses": "object",
		"members_of_contact_groups": "object",
		"restrict_by_contact_groups": "object",
		"restrict_by_custom_macros": "object",
		"the_following_users": "object",
	},
	"CreateClusterHost": {
		"attributes": "",
		"folder": "string",
		"host_name": "string",
		"nodes": "array",
	},
	"CreateFolder": {
		"attributes": "",
		"name": "string",
		"parent": "string",
		"title": "string",
	},
	"CreateHost": {
		"attributes": "",
		"folder": "string",
		"host_name": "string",
	},
	"CreateHostComment": {
		"comment": "string",
		"comment_type": "string",
		"host_name": "string",
		"persistent": "boolean",
	},
	"CreateHostDowntime": {
		"comment": "string",
		"downtime_type": "string",
		"duration": "integer",
		"end_time": "string",
		"host_name": "string",
		"recur": "string",
		"start_time": "string",
	},
	"CreateHostGroupDowntime": {
		"comment": "string",
		"downtime_type": "string",
		"duration": "integer",
		"end_time": "string",
		"hostgroup_name": "string",
		"recur": "string",
		"start_time": "string",
	},
	"CreateHostQueryComment": {
		"comment": "string",
		"comment_type": "string",
		"persistent": "boolean",
		"query": "",
	},
	"CreateHostQueryDowntime": {
		"comment": "string",
		"downtime_type": "string",
		"duration": "integer",
		"end_time": "string",
		"query": "",
		"recur": "string",
		"start_time": "string",
	},
	"CreateServiceComment": {
		"comment": "string",
		"comment_type": "string",
		"host_name": "string",
		"persistent": "boolean",
		"service_description": "string",
	},
	"CreateServiceDowntime": {
		"comment": "string",
		"downtime_type": "string",
		"duration": "integer",
		"end_time": "string",
		"host_name": "string",
		"recur": "string",
		"service_descriptions": "array",
		"start_time": "string",
	},
	"CreateServiceGroupDowntime": {
		"comment": "string",
		"downtime_type": "string",
		"duration": "integer",
		"end_time": "string",
		"recur": "string",
		"servicegroup_name": "string",
		"start_time": "string",
	},
	"CreateServiceQueryComment": {
		"comment": "string",
		"comment_type": "string",
		"persistent": "boolean",
		"query": "",
	},
	"CreateServiceQueryDowntime": {
		"comment": "string",
		"downtime_type": "string",
		"duration": "integer",
		"end_time": "string",
		"query": "",
		"recur": "string",
		"start_time": "string",
	},
	"CreateTimePeriod": {
		"active_time_ranges": "array",
		"alias": "string",
		"exceptions": "array",
		"exclude": "array",
		"name": "string",
	},
	"CreateUser": {
		"auth_option": "",
		"authorized_sites": "array",
		"contact_options": "",
		"contactgroups": "array",
		"disable_login": "boolean",
		"disable_notifications": "",
		"fullname": "string",
		"idle_timeout": "",
		"interface_options": "",
		"language": "string",
		"pager_address": "string",
		"roles": "array",
		"temperature_unit": "string",
		"username": "string",
	},
	"CreateUserRole": {
		"new_alias": "string",
		"new_role_id": "string",
		"role_id": "string",
	},
	"CustomMacro": {
		"macro_name": "string",
		"match_regex": "string",
	},
	"CustomTimeRange": {
		"end_time": "string",
		"start_time": "string",
	},
	"DateTimeRange": {
		"end_time": "string",
		"start_time": "string",
	},
	"DeleteCommentById": {
		"comment_id": "integer",
		"delete_type": "string",
	},
	"DeleteCommentsByParams": {
		"delete_type": "string",
		"host_name": "string",
		"service_descriptions": "array",
	},
	"DeleteCommentsByQuery": {
		"delete_type": "string",
		"query": "",
	},
	"DeleteDowntimeById": {
		"delete_type": "string",
		"downtime_id": "string",
	},
	"DeleteDowntimeByName": {
		"delete_type": "string",
		"host_name": "string",
		"service_descriptions": "array",
	},
	"DeleteDowntimeByQuery": {
		"delete_type": "string",
		"query": "",
	},
	"DirectMapping": {
		"hostname": "string",
		"replace_with": "string",
	},
	"DisabledNotifications": {
		"disable": "boolean",
		"timerange": "",
	},
	"DiscoverServices": {
		"host_name": "string",
		"mode": "string",
	},
	"DiscoverServicesDeprecated": {
		"mode": "string",
	},
	"DiscoveryBackgroundJobStatusObject": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"DomainObject": {
		"domainType": "string",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"DomainObjectCollection": {
		"domainType": "string",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"ECEventAttributes": {
		"application": "string",
		"comment": "string",
		"contact": "string",
		"count": "integer",
		"facility": "string",
		"first": "string",
		"host": "string",
		"ipaddress": "string",
		"last": "string",
		"phase": "string",
		"priority": "string",
		"rule_id": "string",
		"service_level": "string",
		"state": "string",
		"text": "string",
	},
	"ECEventResponse": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"EditUserRole": {
		"new_alias": "string",
		"new_basedon": "string",
		"new_permissions": "object",
		"new_role_id": "string",
	},
	"EmailAndDisplayName": {
		"address": "string",
		"display_name": "string",
	},
	"EventConsoleAlertAttrsResponse": {
		"match_event_comment": "object",
		"match_rule_ids": "object",
		"match_syslog_facility": "object",
		"match_syslog_priority": "object",
	},
	"EventConsoleAlertsResponse": {
		"match_type": "string",
		"state": "string",
		"values": "object",
	},
	"EventConsoleResponseCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"FailedHosts": {
		"failed_hosts": "object",
		"succeeded_hosts": "",
	},
	"FilterById": {
		"event_id": "integer",
		"filter_type": "string",
	},
	"FilterByParams": {
		"filter_type": "string",
		"filters": "object",
	},
	"FilterByQuery": {
		"filter_type": "string",
		"query": "",
	},
	"FilterParams": {
		"application": "string",
		"host": "string",
		"phase": "string",
		"state": "string",
	},
	"FilterParamsUpdateAndAcknowledge": {
		"application": "string",
		"host": "string",
		"state": "string",
	},
	"Folder": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "",
		"title": "string",
	},
	"FolderCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"FolderCreateAttribute": {
		"contactgroups": "",
		"labels": "object",
		"management_ipmi_credentials": "",
		"management_protocol": "string",
		"management_snmp_community": "",
		"network_scan": "",
		"parents": "array",
		"site": "string",
		"snmp_community": "",
		"tag_address_family": "string",
		"tag_agent": "string",
		"tag_criticality": "string",
		"tag_networking": "string",
		"tag_piggyback": "string",
		"tag_snmp_ds": "string",
	},
	"FolderExtensions": {
		"attributes": "",
		"path": "string",
	},
	"FolderMembers": {
		"hosts": "",
		"move": "",
	},
	"FolderUpdateAttribute": {
		"contactgroups": "",
		"labels": "object",
		"management_ipmi_credentials": "",
		"management_protocol": "string",
		"management_snmp_community": "",
		"network_scan": "",
		"parents": "array",
		"site": "string",
		"snmp_community": "",
		"tag_address_family": "string",
		"tag_agent": "string",
		"tag_criticality": "string",
		"tag_networking": "string",
		"tag_piggyback": "string",
		"tag_snmp_ds": "string",
	},
	"FolderViewAttribute": {
		"contactgroups": "",
		"labels": "object",
		"management_ipmi_credentials": "",
		"management_protocol": "string",
		"management_snmp_community": "",
		"meta_data": "",
		"network_scan": "",
		"network_scan_result": "",
		"parents": "array",
		"site": "string",
		"snmp_community": "",
		"tag_address_family": "string",
		"tag_agent": "string",
		"tag_criticality": "string",
		"tag_networking": "string",
		"tag_piggyback": "string",
		"tag_snmp_ds": "string",
	},
	"FromEmailAndNameCheckbox": {
		"state": "string",
		"value": "",
	},
	"FromToNotificationNumbers": {
		"beginning_from": "integer",
		"up_to": "integer",
	},
	"FromToServiceLevels": {
		"from_level": "string",
		"to_level": "string",
	},
	"GetGraph": {
		"graph_id": "string",
		"host_name": "string",
		"reduce": "string",
		"service_description": "string",
		"site": "string",
		"time_range": "",
		"type": "string",
	},
	"GetMetric": {
		"host_name": "string",
		"metric_id": "string",
		"reduce": "string",
		"service_description": "string",
		"site": "string",
		"time_range": "",
		"type": "string",
	},
	"GraphCollection": {
		"metrics": "array",
		"step": "integer",
		"time_range": "",
	},
	"HTMLMailPluginCreate": {
		"bulk_notifications_with_graphs": "object",
		"display_graphs_among_each_other": "object",
		"enable_sync_smtp": "object",
		"from_details": "object",
		"graphs_per_notification": "object",
		"info_to_be_displayed_in_the_email_body": "object",
		"insert_html_section_between_body_and_table": "object",
		"plugin_name": "string",
		"reply_to": "object",
		"send_separate_notification_to_every_recipient": "object",
		"sort_order_for_bulk_notificaions": "object",
		"subject_for_host_notifications": "object",
		"subject_for_service_notifications": "object",
		"url_prefix_for_links_to_checkmk": "object",
	},
	"Heartbeat": {
		"interval": "integer",
		"timeout": "number",
	},
	"Heartbeat1": {
		"interval": "integer",
		"timeout": "number",
	},
	"Host": {
		"type": "",
	},
	"HostConditions": {
		"host_choice": "",
		"host_folder": "string",
		"host_labels": "object",
		"host_tags": "object",
	},
	"HostConfig": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "",
		"title": "string",
	},
	"HostConfigCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"HostConfigSchemaInternal": {
		"is_cluster": "boolean",
		"site": "string",
	},
	"HostContactGroup": {
		"groups": "array",
		"recurse_perms": "boolean",
		"recurse_use": "boolean",
		"use": "boolean",
		"use_for_services": "boolean",
	},
	"HostCreateAttribute": {
		"additional_ipv4addresses": "array",
		"additional_ipv6addresses": "array",
		"alias": "string",
		"contactgroups": "",
		"inventory_failed": "boolean",
		"ipaddress": "string",
		"ipv6address": "string",
		"labels": "object",
		"locked_attributes": "array",
		"locked_by": "",
		"management_address": "string",
		"management_ipmi_credentials": "",
		"management_protocol": "string",
		"management_snmp_community": "",
		"network_scan": "",
		"parents": "array",
		"site": "string",
		"snmp_community": "",
		"tag_address_family": "string",
		"tag_agent": "string",
		"tag_criticality": "string",
		"tag_networking": "string",
		"tag_piggyback": "string",
		"tag_snmp_ds": "string",
	},
	"HostEventType": {
		"acknowledgement_of_problem": "boolean",
		"alert_handler_execution_failed": "boolean",
		"alert_handler_execution_successful": "boolean",
		"any_down": "boolean",
		"any_unreachable": "boolean",
		"any_up": "boolean",
		"down_unreachable": "boolean",
		"down_up": "boolean",
		"start_or_end_of_flapping_state": "boolean",
		"start_or_end_of_scheduled_downtime": "boolean",
		"unreachable_down": "boolean",
		"unreachable_up": "boolean",
		"up_down": "boolean",
		"up_unreachable": "boolean",
	},
	"HostExtensions": {
		"attributes": "",
		"cluster_nodes": "array",
		"effective_attributes": "",
		"folder": "string",
		"is_cluster": "boolean",
		"is_offline": "boolean",
	},
	"HostExtensionsEffectiveAttributes": {
		"additional_ipv4addresses": "array",
		"additional_ipv6addresses": "array",
		"alias": "string",
		"contactgroups": "",
		"inventory_failed": "boolean",
		"ipaddress": "string",
		"ipv6address": "string",
		"labels": "object",
		"locked_attributes": "array",
		"locked_by": "",
		"management_address": "string",
		"management_ipmi_credentials": "",
		"management_protocol": "string",
		"management_snmp_community": "",
		"meta_data": "",
		"network_scan": "",
		"network_scan_result": "",
		"parents": "array",
		"site": "string",
		"snmp_community": "",
		"tag_address_family": "string",
		"tag_agent": "string",
		"tag_criticality": "string",
		"tag_networking": "string",
		"tag_piggyback": "string",
		"tag_snmp_ds": "string",
	},
	"HostGroup": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"HostGroupCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"HostMembers": {
		"folder_config": "",
	},
	"HostOrServiceCondition": {
		"match_on": "array",
		"operator": "string",
	},
	"HostTag": {
		"aux_tags": "array",
		"ident": "string",
		"title": "string",
	},
	"HostTag1": {
		"aux_tags": "array",
		"id": "string",
		"title": "string",
	},
	"HostTagExtensions": {
		"tags": "array",
		"topic": "string",
	},
	"HostTagGroupCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"HostTagValues": {
		"checkmk_agent_api_integration": "string",
		"criticality": "string",
		"ip_address_family": "string",
		"ip_v4": "string",
		"ip_v6": "string",
		"monitor_via_checkmkagent": "string",
		"monitor_via_checkmkagent_or_specialagent": "string",
		"monitor_via_snmp": "string",
		"networking_segment": "string",
		"only_ping_this_device": "string",
		"piggyback": "string",
		"snmp": "string",
	},
	"HostUpdateAttribute": {
		"additional_ipv4addresses": "array",
		"additional_ipv6addresses": "array",
		"alias": "string",
		"contactgroups": "",
		"inventory_failed": "boolean",
		"ipaddress": "string",
		"ipv6address": "string",
		"labels": "object",
		"locked_attributes": "array",
		"locked_by": "",
		"management_address": "string",
		"management_ipmi_credentials": "",
		"management_protocol": "string",
		"management_snmp_community": "",
		"network_scan": "",
		"parents": "array",
		"site": "string",
		"snmp_community": "",
		"tag_address_family": "string",
		"tag_agent": "string",
		"tag_criticality": "string",
		"tag_networking": "string",
		"tag_piggyback": "string",
		"tag_snmp_ds": "string",
	},
	"HostViewAttribute": {
		"additional_ipv4addresses": "array",
		"additional_ipv6addresses": "array",
		"alias": "string",
		"contactgroups": "",
		"inventory_failed": "boolean",
		"ipaddress": "string",
		"ipv6address": "string",
		"labels": "object",
		"locked_attributes": "array",
		"locked_by": "",
		"management_address": "string",
		"management_ipmi_credentials": "",
		"management_protocol": "string",
		"management_snmp_community": "",
		"meta_data": "",
		"network_scan": "",
		"network_scan_result": "",
		"parents": "array",
		"site": "string",
		"snmp_community": "",
		"tag_address_family": "string",
		"tag_agent": "string",
		"tag_criticality": "string",
		"tag_networking": "string",
		"tag_piggyback": "string",
		"tag_snmp_ds": "string",
	},
	"IPAddressRange": {
		"from_address": "string",
		"to_address": "string",
		"type": "",
	},
	"IPAddresses": {
		"addresses": "array",
		"type": "",
	},
	"IPMIParameters": {
		"password": "string",
		"username": "string",
	},
	"IPNetwork": {
		"network": "string",
		"type": "",
	},
	"IPRegexp": {
		"regexp_list": "array",
		"type": "",
	},
	"IdleOption": {
		"duration": "integer",
		"option": "string",
	},
	"IlertAPIKey": {
		"key": "string",
		"option": "string",
	},
	"IlertPasswordStoreID": {
		"option": "string",
		"store_id": "string",
	},
	"IlertPluginCreate": {
		"api_key": "object",
		"custom_summary_for_host_alerts": "string",
		"custom_summary_for_service_alerts": "string",
		"disable_ssl_cert_verification": "",
		"http_proxy": "",
		"notification_priority": "string",
		"plugin_name": "string",
		"url_prefix_for_links_to_checkmk": "object",
	},
	"IncidentParams": {
		"caller": "string",
		"host_description": "object",
		"host_short_description": "object",
		"impact": "object",
		"service_description": "object",
		"service_short_description": "object",
		"state_acknowledgement": "object",
		"state_downtime": "object",
		"state_recovery": "object",
		"urgency": "object",
	},
	"InputContactGroup": {
		"alias": "string",
		"name": "string",
	},
	"InputHostGroup": {
		"alias": "string",
		"name": "string",
	},
	"InputHostTagGroup": {
		"help": "string",
		"ident": "string",
		"tags": "array",
		"title": "string",
		"topic": "string",
	},
	"InputPassword": {
		"comment": "string",
		"documentation_url": "string",
		"ident": "string",
		"owner": "string",
		"password": "string",
		"shared": "array",
		"title": "string",
	},
	"InputRuleObject": {
		"conditions": "",
		"folder": "string",
		"properties": "",
		"ruleset": "string",
		"value_raw": "string",
	},
	"InputServiceGroup": {
		"alias": "string",
		"name": "string",
	},
	"InstalledVersions": {
		"demo": "boolean",
		"edition": "string",
		"group": "string",
		"rest_api": "object",
		"site": "string",
		"versions": "object",
	},
	"JiraPluginCreate": {
		"disable_ssl_cert_verification": "",
		"host_custom_id": "string",
		"host_summary": "",
		"issue_type_id": "string",
		"jira_url": "string",
		"label": "",
		"monitoring_url": "string",
		"optional_timeout": "",
		"password": "string",
		"plugin_name": "string",
		"priority_id": "",
		"project_id": "string",
		"resolution_id": "",
		"service_custom_id": "string",
		"service_summary": "",
		"site_custom_id": "",
		"username": "string",
	},
	"JobLogs": {
		"progress": "array",
		"result": "array",
	},
	"LabelCondition": {
		"key": "string",
		"operator": "string",
		"value": "string",
	},
	"Link": {
		"body_params": "object",
		"domainType": "",
		"href": "string",
		"method": "string",
		"rel": "string",
		"title": "string",
		"type": "string",
	},
	"LinkHostUUID": {
		"uuid": "string",
	},
	"LockedBy": {
		"instance_id": "string",
		"program_id": "string",
		"site_id": "string",
	},
	"LogicalExpr": {
		"expr": "array",
		"op": "string",
	},
	"MSTeamsExplicitWebhookUrl": {
		"option": "string",
		"url": "string",
	},
	"MSTeamsPluginCreate": {
		"affected_host_groups": "",
		"host_details": "",
		"host_summary": "",
		"host_title": "",
		"http_proxy": "",
		"plugin_name": "string",
		"service_details": "",
		"service_summary": "",
		"service_title": "",
		"url_prefix_for_links_to_checkmk": "object",
		"webhook_url": "object",
	},
	"MSTeamsURLResponse": {
		"option": "string",
		"store_id": "string",
		"url": "string",
	},
	"MatchCustomMacros": {
		"state": "string",
		"value": "array",
	},
	"MatchEventConsoleAlertsResponse": {
		"state": "string",
		"value": "object",
	},
	"MetaData": {
		"created_at": "string",
		"created_by": "string",
		"updated_at": "string",
	},
	"Metric": {
		"color": "string",
		"data_points": "array",
		"line_type": "string",
		"title": "string",
	},
	"MgmntTypeCaseParams": {
		"option": "string",
		"params": "object",
	},
	"MgmntTypeIncidentParams": {
		"option": "string",
		"params": "object",
	},
	"MkEventDPluginCreate": {
		"ip_address_of_remote_event_console": "object",
		"plugin_name": "string",
		"syslog_facility_to_use": "object",
	},
	"MoveFolder": {
		"destination": "string",
	},
	"MoveHost": {
		"target_folder": "string",
	},
	"MoveToFolder": {
		"folder": "string",
		"position": "string",
	},
	"MoveToSpecificRule": {
		"position": "string",
		"rule_id": "string",
	},
	"NetworkScan": {
		"addresses": "array",
		"exclude_addresses": "array",
		"max_parallel_pings": "integer",
		"run_as": "string",
		"scan_interval": "integer",
		"set_ip_address": "boolean",
		"tag_criticality": "string",
		"time_allowed": "array",
		"translate_names": "object",
	},
	"NetworkScanResult": {
		"end": "string",
		"output": "string",
		"start": "string",
		"state": "string",
	},
	"NotExpr": {
		"expr": "",
		"op": "string",
	},
	"NotificationBulking": {
		"bulk_outside_timeperiod": "object",
		"max_bulk_size": "integer",
		"notification_bulks_based_on": "array",
		"notification_bulks_based_on_custom_macros": "array",
		"state": "string",
		"subject_for_bulk_notifications": "object",
		"time_horizon": "integer",
		"time_period": "string",
	},
	"NotificationBulkingCheckbox": {
		"state": "string",
		"value": "object",
	},
	"NotificationBulkingCommonAttributes": {
		"max_bulk_size": "integer",
		"notification_bulks_based_on": "array",
		"notification_bulks_based_on_custom_macros": "array",
		"state": "string",
		"subject_for_bulk_notifications": "object",
		"time_horizon": "integer",
	},
	"NotificationPlugin": {
		"notification_bulking": "object",
		"notify_plugin": "object",
	},
	"NotificationRuleAttributes": {
		"conditions": "object",
		"contact_selection": "object",
		"notification_method": "object",
		"rule_properties": "object",
	},
	"NotificationRuleConfig": {
		"rule_config": "object",
	},
	"NotificationRuleRequest": {
		"rule_config": "",
	},
	"NotificationRuleResponse": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"NotificationRuleResponseCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"ObjectActionMember": {
		"disabledReason": "string",
		"id": "string",
		"invalidReason": "string",
		"links": "array",
		"memberType": "",
		"name": "string",
		"parameters": "object",
		"title": "string",
		"x-ro-invalidReason": "string",
	},
	"ObjectCollectionMember": {
		"disabledReason": "string",
		"id": "string",
		"invalidReason": "string",
		"links": "array",
		"memberType": "",
		"name": "string",
		"title": "string",
		"value": "array",
		"x-ro-invalidReason": "string",
	},
	"ObjectProperty": {
		"extensions": "object",
		"id": "string",
		"links": "array",
		"value": "array",
	},
	"OpsGenieExplicitKey": {
		"key": "string",
		"option": "string",
	},
	"OpsGeniePluginCreate": {
		"actions": "",
		"api_key": "object",
		"desc_for_host_alerts": "",
		"desc_for_service_alerts": "",
		"domain": "",
		"entity": "",
		"http_proxy": "",
		"message_for_host_alerts": "",
		"message_for_service_alerts": "",
		"note_while_closing": "",
		"note_while_creating": "",
		"owner": "",
		"plugin_name": "string",
		"priority": "object",
		"responsible_teams": "",
		"source": "",
		"tags": "",
	},
	"OpsGenieStoreID": {
		"option": "string",
		"store_id": "string",
	},
	"PagerDutyAPIKeyStoreID": {
		"option": "string",
		"store_id": "string",
	},
	"PagerDutyExplicitKey": {
		"key": "string",
		"option": "string",
	},
	"PagerDutyPluginCreate": {
		"disable_ssl_cert_verification": "",
		"http_proxy": "",
		"integration_key": "object",
		"plugin_name": "string",
		"url_prefix_for_links_to_checkmk": "object",
	},
	"Parent": {
		"type": "",
	},
	"PasswordCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"PasswordExtension": {
		"comment": "string",
		"documentation_url": "string",
		"ident": "string",
		"owned_by": "string",
		"shared": "array",
		"title": "string",
	},
	"PasswordObject": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"PendingChangesCollection": {
		"domainType": "",
		"extensions": "object",
		"links": "array",
		"value": "array",
	},
	"PluginBase": {
		"option": "string",
		"plugin_params": "object",
	},
	"PluginBase1": {
		"option": "string",
	},
	"PluginName": {
		"plugin_name": "string",
	},
	"PluginWithParams": {
		"option": "string",
		"plugin_params": "object",
	},
	"ProxyAttributes": {
		"global_settings": "boolean",
		"params": "",
		"tcp": "",
		"use_livestatus_daemon": "string",
	},
	"ProxyAttributes1": {
		"global_settings": "boolean",
		"params": "",
		"tcp": "",
		"use_livestatus_daemon": "string",
	},
	"ProxyParams": {
		"cache": "boolean",
		"channel_timeout": "number",
		"channels": "integer",
		"connect_retry": "number",
		"heartbeat": "",
		"query_timeout": "number",
	},
	"ProxyParams1": {
		"cache": "boolean",
		"channel_timeout": "number",
		"channels": "integer",
		"connect_retry": "number",
		"heartbeat": "",
		"query_timeout": "number",
	},
	"ProxyTcp": {
		"only_from": "array",
		"port": "integer",
		"tls": "boolean",
	},
	"ProxyTcp1": {
		"only_from": "array",
		"port": "integer",
		"tls": "boolean",
	},
	"PushOverPluginCreate": {
		"api_key": "string",
		"http_proxy": "",
		"plugin_name": "string",
		"priority": "object",
		"sound": "object",
		"url_prefix_for_links_to_checkmk": "",
		"user_group_key": "string",
	},
	"RegexpRewrites": {
		"replace_with": "string",
		"search": "string",
	},
	"RegisterHost": {
		"uuid": "string",
	},
	"RenameHost": {
		"new_name": "string",
	},
	"RuleCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"RuleConditions": {
		"event_console_alerts": "object",
		"match_check_types": "object",
		"match_contact_groups": "object",
		"match_exclude_hosts": "object",
		"match_exclude_service_groups": "object",
		"match_exclude_service_groups_regex": "object",
		"match_exclude_services": "object",
		"match_folder": "object",
		"match_host_event_type": "object",
		"match_host_groups": "object",
		"match_host_labels": "object",
		"match_host_tags": "object",
		"match_hosts": "object",
		"match_notification_comment": "object",
		"match_only_during_time_period": "object",
		"match_plugin_output": "object",
		"match_service_event_type": "object",
		"match_service_groups": "object",
		"match_service_groups_regex": "object",
		"match_service_labels": "object",
		"match_service_levels": "object",
		"match_services": "object",
		"match_sites": "object",
		"restrict_to_notification_numbers": "object",
		"throttle_periodic_notifications": "object",
	},
	"RuleConditions1": {
		"host_labels": "array",
		"host_name": "",
		"host_tags": "array",
		"service_description": "",
		"service_labels": "array",
	},
	"RuleExtensions": {
		"conditions": "",
		"folder": "string",
		"folder_index": "integer",
		"properties": "",
		"ruleset": "string",
		"value_raw": "string",
	},
	"RuleNotification": {
		"conditions": "object",
		"contact_selection": "object",
		"notification_method": "object",
		"rule_properties": "object",
	},
	"RuleNotificationMethod": {
		"notification_bulking": "object",
		"notify_plugin": "object",
	},
	"RuleObject": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"RuleProperties": {
		"allow_users_to_deactivate": "",
		"comment": "string",
		"description": "string",
		"do_not_apply_this_rule": "",
		"documentation_url": "string",
	},
	"RuleProperties1": {
		"comment": "string",
		"description": "string",
		"disabled": "boolean",
		"documentation_url": "string",
	},
	"RulePropertiesAttributes": {
		"allow_users_to_deactivate": "",
		"comment": "string",
		"description": "string",
		"do_not_apply_this_rule": "",
		"documentation_url": "string",
	},
	"RulesetCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"RulesetExtensions": {
		"folder": "string",
		"name": "string",
		"number_of_rules": "integer",
	},
	"RulesetObject": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"SMSAPIExplicitPassword": {
		"option": "string",
		"password": "string",
	},
	"SMSAPIPStoreID": {
		"option": "string",
		"store_id": "string",
	},
	"SMSAPIPluginCreate": {
		"disable_ssl_cert_verification": "",
		"http_proxy": "",
		"modem_type": "string",
		"modem_url": "string",
		"plugin_name": "string",
		"timeout": "string",
		"user_password": "object",
		"username": "string",
	},
	"SMSPluginBase": {
		"params": "array",
		"plugin_name": "string",
	},
	"SNMPCommunity": {
		"community": "string",
		"type": "",
	},
	"SNMPv3AuthNoPrivacy": {
		"auth_password": "string",
		"auth_protocol": "string",
		"security_name": "string",
		"type": "",
	},
	"SNMPv3AuthPrivacy": {
		"auth_password": "string",
		"auth_protocol": "string",
		"privacy_password": "string",
		"privacy_protocol": "string",
		"security_name": "string",
		"type": "",
	},
	"SNMPv3NoAuthNoPrivacy": {
		"security_name": "string",
		"type": "",
	},
	"ServiceConditions": {
		"host_choice": "",
		"host_folder": "string",
		"host_labels": "object",
		"host_tags": "object",
		"service_labels": "object",
		"service_regex": "string",
	},
	"ServiceEventType": {
		"acknowledgement_of_problem": "boolean",
		"alert_handler_execution_failed": "boolean",
		"alert_handler_execution_successful": "boolean",
		"any_crit": "boolean",
		"any_ok": "boolean",
		"any_unknown": "boolean",
		"any_warn": "boolean",
		"crit_ok": "boolean",
		"crit_unknown": "boolean",
		"crit_warn": "boolean",
		"ok_crit": "boolean",
		"ok_ok": "boolean",
		"ok_unknown": "boolean",
		"ok_warn": "boolean",
		"start_or_end_of_flapping_state": "boolean",
		"start_or_end_of_scheduled_downtime": "boolean",
		"unknown_crit": "boolean",
		"unknown_ok": "boolean",
		"unknown_warn": "boolean",
		"warn_crit": "boolean",
		"warn_ok": "boolean",
		"warn_unknown": "boolean",
	},
	"ServiceGroup": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"ServiceGroupCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"ServiceGroupsRegex": {
		"match_type": "string",
		"regex_list": "array",
	},
	"ServiceNowExplicitPassword": {
		"option": "string",
		"password": "string",
	},
	"ServiceNowPasswordStoreID": {
		"option": "string",
		"store_id": "string",
	},
	"ServiceNowPluginCreate": {
		"http_proxy": "",
		"management_type": "object",
		"optional_timeout": "object",
		"plugin_name": "string",
		"servicenow_url": "string",
		"use_site_id_prefix": "object",
		"user_password": "object",
		"username": "string",
	},
	"SignL4TeamSecret": {
		"option": "string",
		"secret": "string",
	},
	"SignL4TeamSecretStoreID": {
		"option": "string",
		"store_id": "string",
	},
	"Signl4PluginCreate": {
		"disable_ssl_cert_verification": "",
		"http_proxy": "",
		"plugin_name": "string",
		"team_secret": "object",
		"url_prefix_for_links_to_checkmk": "object",
	},
	"SiteConfigAttributes": {
		"basic_settings": "object",
		"configuration_connection": "object",
		"secret": "string",
		"status_connection": "object",
	},
	"SiteConfigAttributesCreate": {
		"basic_settings": "object",
		"configuration_connection": "object",
		"secret": "string",
		"status_connection": "object",
	},
	"SiteConfigAttributesUpdate": {
		"basic_settings": "object",
		"configuration_connection": "object",
		"secret": "string",
		"status_connection": "object",
	},
	"SiteConnectionRequestCreate": {
		"site_config": "",
	},
	"SiteConnectionRequestUpdate": {
		"site_config": "",
	},
	"SiteConnectionResponse": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"SiteConnectionResponseCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"SiteLoginRequest": {
		"password": "string",
		"username": "string",
	},
	"SlackPluginCreate": {
		"disable_ssl_cert_verification": "",
		"http_proxy": "",
		"plugin_name": "string",
		"url_prefix_for_links_to_checkmk": "object",
		"webhook_url": "object",
	},
	"SlackWebhookStore": {
		"option": "string",
		"store_id": "string",
	},
	"SlackWebhookURL": {
		"option": "string",
		"url": "string",
	},
	"SocketAttributes1": {
		"encrypted": "boolean",
		"host": "string",
		"path": "string",
		"port": "integer",
		"socket_type": "string",
		"verify": "boolean",
	},
	"SocketIP4": {
		"encrypted": "boolean",
		"host": "string",
		"port": "integer",
		"socket_type": "string",
		"verify": "boolean",
	},
	"SocketIP6": {
		"encrypted": "boolean",
		"host": "string",
		"port": "integer",
		"socket_type": "string",
		"verify": "boolean",
	},
	"SocketType": {
		"socket_type": "string",
	},
	"SocketUnixAttributes": {
		"path": "string",
		"socket_type": "string",
	},
	"SpectrumPluginBase": {
		"base_oid": "string",
		"destination_ip": "string",
		"plugin_name": "string",
		"snmp_community": "string",
	},
	"SplunkStoreID": {
		"option": "string",
		"store_id": "string",
	},
	"SplunkURLExplicit": {
		"option": "string",
		"url": "string",
	},
	"StatusConnectionAttributes": {
		"connect_timeout": "integer",
		"connection": "",
		"disable_in_status_gui": "boolean",
		"persistent_connection": "boolean",
		"proxy": "",
		"status_host": "",
		"url_prefix": "string",
	},
	"StatusConnectionAttributes1": {
		"connect_timeout": "integer",
		"connection": "",
		"disable_in_status_gui": "boolean",
		"persistent_connection": "boolean",
		"proxy": "",
		"status_host": "",
		"url_prefix": "string",
	},
	"StatusHostAttributes": {
		"host": "string",
		"site": "string",
		"status_host_set": "string",
	},
	"StatusHostAttributesBase": {
		"status_host_set": "string",
	},
	"StatusHostAttributesSet": {
		"host": "string",
		"site": "string",
		"status_host_set": "string",
	},
	"SysLogToFromPriorities": {
		"from_priority": "string",
		"to_priority": "string",
	},
	"TagConditionConditionSchemaBase": {
		"key": "string",
		"operator": "string",
		"value": "array",
	},
	"TagConditionScalarSchemaBase": {
		"key": "string",
		"operator": "string",
		"value": "string",
	},
	"ThrottlePeriodicNotifications": {
		"beginning_from": "integer",
		"send_every_nth_notification": "integer",
	},
	"TimeAllowedRange": {
		"end": "string",
		"start": "string",
	},
	"TimePeriodAttrsResponse": {
		"active_time_ranges": "array",
		"alias": "string",
		"exceptions": "array",
		"exclude": "array",
	},
	"TimePeriodException": {
		"date": "string",
		"time_ranges": "array",
	},
	"TimePeriodResponse": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"TimePeriodResponseCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"TimeRange": {
		"end": "string",
		"start": "string",
	},
	"TimeRange1": {
		"end": "string",
		"start": "string",
	},
	"TimeRangeActive": {
		"day": "string",
		"time_ranges": "array",
	},
	"TranslateNames": {
		"convert_case": "string",
		"drop_domain": "boolean",
		"hostname_replacement": "array",
		"regexp_rewrites": "array",
	},
	"UpdateAndAcknowledgeEvent": {
		"change_comment": "string",
		"change_contact": "string",
		"phase": "string",
	},
	"UpdateAndAcknowledgeFilter": {
		"change_comment": "string",
		"change_contact": "string",
		"filter_type": "string",
		"phase": "string",
	},
	"UpdateAndAcknowledgeWithParams": {
		"change_comment": "string",
		"change_contact": "string",
		"filter_type": "string",
		"filters": "object",
		"phase": "string",
	},
	"UpdateAndAcknowledgeWithQuery": {
		"change_comment": "string",
		"change_contact": "string",
		"filter_type": "string",
		"phase": "string",
		"query": "",
	},
	"UpdateContactGroup": {
		"attributes": "object",
		"name": "string",
	},
	"UpdateDiscoveryPhase": {
		"check_type": "string",
		"service_item": "string",
		"target_phase": "string",
	},
	"UpdateFolder": {
		"attributes": "",
		"title": "string",
	},
	"UpdateFolderEntry": {
		"attributes": "",
		"folder": "string",
		"title": "string",
	},
	"UpdateGroup": {
		"alias": "string",
	},
	"UpdateGroup1": {
		"alias": "string",
	},
	"UpdateGroup2": {
		"alias": "string",
	},
	"UpdateHost": {
		"attributes": "",
	},
	"UpdateHostEntry": {
		"attributes": "",
		"host_name": "string",
	},
	"UpdateHostGroup": {
		"attributes": "object",
		"name": "string",
	},
	"UpdateHostTagGroup": {
		"help": "string",
		"repair": "boolean",
		"tags": "array",
		"title": "string",
		"topic": "string",
	},
	"UpdateNodes": {
		"nodes": "array",
	},
	"UpdatePassword": {
		"comment": "string",
		"documentation_url": "string",
		"owner": "string",
		"password": "string",
		"shared": "array",
		"title": "string",
	},
	"UpdateServiceGroup": {
		"attributes": "object",
		"name": "string",
	},
	"UpdateTimePeriod": {
		"active_time_ranges": "array",
		"alias": "string",
		"exceptions": "array",
	},
	"UpdateUser": {
		"auth_option": "",
		"authorized_sites": "array",
		"contact_options": "",
		"contactgroups": "array",
		"disable_login": "boolean",
		"disable_notifications": "",
		"fullname": "string",
		"idle_timeout": "",
		"interface_options": "",
		"language": "string",
		"pager_address": "string",
		"roles": "array",
		"temperature_unit": "string",
	},
	"UseLiveStatusDaemon": {
		"use_livestatus_daemon": "string",
	},
	"UserCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"UserContactOption": {
		"email": "string",
		"fallback_contact": "boolean",
	},
	"UserIdleOption": {
		"duration": "integer",
		"option": "string",
	},
	"UserInterfaceAttributes": {
		"interface_theme": "string",
		"mega_menu_icons": "string",
		"navigation_bar_icons": "string",
		"show_mode": "string",
		"sidebar_position": "string",
	},
	"UserInterfaceUpdateAttributes": {
		"interface_theme": "string",
		"mega_menu_icons": "string",
		"navigation_bar_icons": "string",
		"show_mode": "string",
		"sidebar_position": "string",
	},
	"UserObject": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"UserRoleAttributes": {
		"alias": "string",
		"basedon": "string",
		"builtin": "boolean",
		"permissions": "array",
	},
	"UserRoleCollection": {
		"domainType": "",
		"extensions": "object",
		"id": "string",
		"links": "array",
		"title": "string",
		"value": "array",
	},
	"UserRoleObject": {
		"domainType": "",
		"extensions": "",
		"id": "string",
		"links": "array",
		"members": "object",
		"title": "string",
	},
	"UserSyncAttributes1": {
		"ldap_connections": "array",
		"sync_with_ldap_connections": "string",
	},
	"UserSyncBase": {
		"sync_with_ldap_connections": "string",
	},
	"UserSyncWithLdapConnection": {
		"ldap_connections": "array",
		"sync_with_ldap_connections": "string",
	},
	"VictoropsPluginCreate": {
		"disable_ssl_cert_verification": "",
		"http_proxy": "",
		"plugin_name": "string",
		"splunk_on_call_rest_endpoint": "object",
		"url_prefix_for_links_to_checkmk": "object",
	},
	"WhenToBulk": {
		"params": "object",
		"when_to_bulk": "string",
	},
	"X509PEM": {
		"cert": "string",
	},
	"X509ReqPEMUUID": {
		"csr": "string",
	},
}

// GetFieldDescription returns the description for a field in a schema.
// Returns empty string if not found.
func GetFieldDescription(schemaName, fieldName string) string {
	if fields, ok := FieldDescriptions[schemaName]; ok {
		return fields[fieldName]
	}
	return ""
}

// GetFieldType returns the OpenAPI type for a field in a schema.
// Returns empty string if not found.
func GetFieldType(schemaName, fieldName string) string {
	if fields, ok := FieldTypes[schemaName]; ok {
		return fields[fieldName]
	}
	return ""
}

// IsReadOnlyField checks if a field is read-only for a given schema.
func IsReadOnlyField(schemaName, fieldName string) bool {
	switch schemaName {
	}
	return false
}

// IsRequiredField checks if a field is required for a given schema.
func IsRequiredField(schemaName, fieldName string) bool {
	switch schemaName {
	case "AcknowledgeHostGroupProblem":
		for _, f := range AcknowledgeHostGroupProblemRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AcknowledgeHostProblem":
		for _, f := range AcknowledgeHostProblemRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AcknowledgeHostQueryProblem":
		for _, f := range AcknowledgeHostQueryProblemRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AcknowledgeServiceGroupProblem":
		for _, f := range AcknowledgeServiceGroupProblemRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AcknowledgeServiceQueryProblem":
		for _, f := range AcknowledgeServiceQueryProblemRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AcknowledgeSpecificServiceProblem":
		for _, f := range AcknowledgeSpecificServiceProblemRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ActivationRunCollection":
		for _, f := range ActivationRunCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ActivationRunResponse":
		for _, f := range ActivationRunResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AgentControllerCertificateSettings":
		for _, f := range AgentControllerCertificateSettingsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ApiError":
		for _, f := range ApiErrorRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AsciiMailPluginCreate":
		for _, f := range AsciiMailPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AuthUpdatePassword":
		for _, f := range AuthUpdatePasswordRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AuthUpdateRemove":
		for _, f := range AuthUpdateRemoveRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AuthUpdateSecret":
		for _, f := range AuthUpdateSecretRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AuxTagAttrsCreate":
		for _, f := range AuxTagAttrsCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AuxTagAttrsResponse":
		for _, f := range AuxTagAttrsResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AuxTagResponse":
		for _, f := range AuxTagResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "AuxTagResponseCollection":
		for _, f := range AuxTagResponseCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIAggregationComputationOptions":
		for _, f := range BIAggregationComputationOptionsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIAggregationEndpoint":
		for _, f := range BIAggregationEndpointRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIAggregationFunctionBest":
		for _, f := range BIAggregationFunctionBestRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIAggregationFunctionCountOK":
		for _, f := range BIAggregationFunctionCountOKRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIAggregationFunctionCountSettings":
		for _, f := range BIAggregationFunctionCountSettingsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIAggregationFunctionWorst":
		for _, f := range BIAggregationFunctionWorstRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIAggregationVisualization":
		for _, f := range BIAggregationVisualizationRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIAllHostsChoice":
		for _, f := range BIAllHostsChoiceRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BICallARuleAction":
		for _, f := range BICallARuleActionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIEmptySearch":
		for _, f := range BIEmptySearchRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIFixedArgumentsSearch":
		for _, f := range BIFixedArgumentsSearchRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIFixedArgumentsSearchToken":
		for _, f := range BIFixedArgumentsSearchTokenRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIHostAliasRegexChoice":
		for _, f := range BIHostAliasRegexChoiceRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIHostNameRegexChoice":
		for _, f := range BIHostNameRegexChoiceRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIHostSearch":
		for _, f := range BIHostSearchRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BINodeGenerator":
		for _, f := range BINodeGeneratorRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BINodeVisBlockStyle":
		for _, f := range BINodeVisBlockStyleRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BINodeVisForceStyle":
		for _, f := range BINodeVisForceStyleRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BINodeVisHierarchyStyle":
		for _, f := range BINodeVisHierarchyStyleRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BINodeVisHierarchyStyleConfig":
		for _, f := range BINodeVisHierarchyStyleConfigRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BINodeVisNoneStyle":
		for _, f := range BINodeVisNoneStyleRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BINodeVisRadialStyle":
		for _, f := range BINodeVisRadialStyleRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BINodeVisRadialStyleConfig":
		for _, f := range BINodeVisRadialStyleConfigRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIPackEndpoint":
		for _, f := range BIPackEndpointRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIParams":
		for _, f := range BIParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIRuleComputationOptions":
		for _, f := range BIRuleComputationOptionsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIRuleEndpoint":
		for _, f := range BIRuleEndpointRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIRuleProperties":
		for _, f := range BIRulePropertiesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIServiceSearch":
		for _, f := range BIServiceSearchRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIStateOfHostAction":
		for _, f := range BIStateOfHostActionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIStateOfRemainingServicesAction":
		for _, f := range BIStateOfRemainingServicesActionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BIStateOfServiceAction":
		for _, f := range BIStateOfServiceActionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BackgroundJobStatus":
		for _, f := range BackgroundJobStatusRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BaseUserAttributes":
		for _, f := range BaseUserAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BasicSettingsAttributes":
		for _, f := range BasicSettingsAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BasicSettingsAttributesCreate":
		for _, f := range BasicSettingsAttributesCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BasicSettingsAttributesUpdate":
		for _, f := range BasicSettingsAttributesUpdateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkCreateHost":
		for _, f := range BulkCreateHostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkDeleteContactGroup":
		for _, f := range BulkDeleteContactGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkDeleteHost":
		for _, f := range BulkDeleteHostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkDeleteHostGroup":
		for _, f := range BulkDeleteHostGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkDeleteServiceGroup":
		for _, f := range BulkDeleteServiceGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkDiscovery":
		for _, f := range BulkDiscoveryRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkHostActionWithFailedHosts":
		for _, f := range BulkHostActionWithFailedHostsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkInputContactGroup":
		for _, f := range BulkInputContactGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkInputHostGroup":
		for _, f := range BulkInputHostGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkInputServiceGroup":
		for _, f := range BulkInputServiceGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkOutsideTimePeriodValue":
		for _, f := range BulkOutsideTimePeriodValueRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkUpdateContactGroup":
		for _, f := range BulkUpdateContactGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkUpdateFolder":
		for _, f := range BulkUpdateFolderRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkUpdateHost":
		for _, f := range BulkUpdateHostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkUpdateHostGroup":
		for _, f := range BulkUpdateHostGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "BulkUpdateServiceGroup":
		for _, f := range BulkUpdateServiceGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ChangeEventState":
		for _, f := range ChangeEventStateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ChangeStateWithParams":
		for _, f := range ChangeStateWithParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ChangeStateWithQuery":
		for _, f := range ChangeStateWithQueryRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "Checkbox":
		for _, f := range CheckboxRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxHostEventType":
		for _, f := range CheckboxHostEventTypeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxLabel":
		for _, f := range CheckboxLabelRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxMatchHostTags":
		for _, f := range CheckboxMatchHostTagsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxRestrictNotificationNumbers":
		for _, f := range CheckboxRestrictNotificationNumbersRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxServiceEventType":
		for _, f := range CheckboxServiceEventTypeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxThrottlePeriodicNotifcations":
		for _, f := range CheckboxThrottlePeriodicNotifcationsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxWithFromToServiceLevels":
		for _, f := range CheckboxWithFromToServiceLevelsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxWithListOfLabels":
		for _, f := range CheckboxWithListOfLabelsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxWithListOfServiceGroupsRegex":
		for _, f := range CheckboxWithListOfServiceGroupsRegexRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxWithListOfStr":
		for _, f := range CheckboxWithListOfStrRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxWithStr":
		for _, f := range CheckboxWithStrRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxWithStrValue":
		for _, f := range CheckboxWithStrValueRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CheckboxWithSysLogPriority":
		for _, f := range CheckboxWithSysLogPriorityRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "Child":
		for _, f := range ChildRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ChildWith":
		for _, f := range ChildWithRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CiscoExplicitWebhookUrl":
		for _, f := range CiscoExplicitWebhookUrlRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CiscoPasswordStore":
		for _, f := range CiscoPasswordStoreRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CiscoWebexPluginCreate":
		for _, f := range CiscoWebexPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CommentAttributes":
		for _, f := range CommentAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CommentCollection":
		for _, f := range CommentCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CommentObject":
		for _, f := range CommentObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ConcreteHostTagGroup":
		for _, f := range ConcreteHostTagGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ConcreteUserContactOption":
		for _, f := range ConcreteUserContactOptionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ConfigurationConnectionAttributes":
		for _, f := range ConfigurationConnectionAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ConfigurationConnectionAttributes1":
		for _, f := range ConfigurationConnectionAttributes1RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ContactGroup":
		for _, f := range ContactGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ContactGroupCollection":
		for _, f := range ContactGroupCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ContactSelection":
		for _, f := range ContactSelectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateClusterHost":
		for _, f := range CreateClusterHostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateFolder":
		for _, f := range CreateFolderRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateHost":
		for _, f := range CreateHostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateHostComment":
		for _, f := range CreateHostCommentRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateHostDowntime":
		for _, f := range CreateHostDowntimeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateHostGroupDowntime":
		for _, f := range CreateHostGroupDowntimeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateHostQueryComment":
		for _, f := range CreateHostQueryCommentRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateHostQueryDowntime":
		for _, f := range CreateHostQueryDowntimeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateServiceComment":
		for _, f := range CreateServiceCommentRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateServiceDowntime":
		for _, f := range CreateServiceDowntimeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateServiceGroupDowntime":
		for _, f := range CreateServiceGroupDowntimeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateServiceQueryComment":
		for _, f := range CreateServiceQueryCommentRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateServiceQueryDowntime":
		for _, f := range CreateServiceQueryDowntimeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateTimePeriod":
		for _, f := range CreateTimePeriodRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateUser":
		for _, f := range CreateUserRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CreateUserRole":
		for _, f := range CreateUserRoleRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CustomMacro":
		for _, f := range CustomMacroRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "CustomTimeRange":
		for _, f := range CustomTimeRangeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DateTimeRange":
		for _, f := range DateTimeRangeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DeleteCommentById":
		for _, f := range DeleteCommentByIdRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DeleteCommentsByParams":
		for _, f := range DeleteCommentsByParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DeleteCommentsByQuery":
		for _, f := range DeleteCommentsByQueryRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DeleteDowntimeById":
		for _, f := range DeleteDowntimeByIdRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DeleteDowntimeByName":
		for _, f := range DeleteDowntimeByNameRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DeleteDowntimeByQuery":
		for _, f := range DeleteDowntimeByQueryRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DirectMapping":
		for _, f := range DirectMappingRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DiscoverServices":
		for _, f := range DiscoverServicesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DiscoveryBackgroundJobStatusObject":
		for _, f := range DiscoveryBackgroundJobStatusObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DomainObject":
		for _, f := range DomainObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "DomainObjectCollection":
		for _, f := range DomainObjectCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ECEventAttributes":
		for _, f := range ECEventAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ECEventResponse":
		for _, f := range ECEventResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "EventConsoleAlertsResponse":
		for _, f := range EventConsoleAlertsResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "EventConsoleResponseCollection":
		for _, f := range EventConsoleResponseCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "FilterById":
		for _, f := range FilterByIdRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "FilterByParams":
		for _, f := range FilterByParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "FilterByQuery":
		for _, f := range FilterByQueryRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "Folder":
		for _, f := range FolderRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "FolderCollection":
		for _, f := range FolderCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "FromEmailAndNameCheckbox":
		for _, f := range FromEmailAndNameCheckboxRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "FromToNotificationNumbers":
		for _, f := range FromToNotificationNumbersRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "FromToServiceLevels":
		for _, f := range FromToServiceLevelsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "GetGraph":
		for _, f := range GetGraphRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "GetMetric":
		for _, f := range GetMetricRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "GraphCollection":
		for _, f := range GraphCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HTMLMailPluginCreate":
		for _, f := range HTMLMailPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "Host":
		for _, f := range HostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostConditions":
		for _, f := range HostConditionsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostConfig":
		for _, f := range HostConfigRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostConfigCollection":
		for _, f := range HostConfigCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostConfigSchemaInternal":
		for _, f := range HostConfigSchemaInternalRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostContactGroup":
		for _, f := range HostContactGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostEventType":
		for _, f := range HostEventTypeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostGroup":
		for _, f := range HostGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostGroupCollection":
		for _, f := range HostGroupCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostTag":
		for _, f := range HostTagRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostTagGroupCollection":
		for _, f := range HostTagGroupCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "HostTagValues":
		for _, f := range HostTagValuesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "IPMIParameters":
		for _, f := range IPMIParametersRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "IdleOption":
		for _, f := range IdleOptionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "IlertAPIKey":
		for _, f := range IlertAPIKeyRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "IlertPasswordStoreID":
		for _, f := range IlertPasswordStoreIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "IlertPluginCreate":
		for _, f := range IlertPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "IncidentParams":
		for _, f := range IncidentParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "InputContactGroup":
		for _, f := range InputContactGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "InputHostGroup":
		for _, f := range InputHostGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "InputHostTagGroup":
		for _, f := range InputHostTagGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "InputPassword":
		for _, f := range InputPasswordRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "InputRuleObject":
		for _, f := range InputRuleObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "InputServiceGroup":
		for _, f := range InputServiceGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "JiraPluginCreate":
		for _, f := range JiraPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "LabelCondition":
		for _, f := range LabelConditionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "Link":
		for _, f := range LinkRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "LinkHostUUID":
		for _, f := range LinkHostUUIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "LockedBy":
		for _, f := range LockedByRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MSTeamsExplicitWebhookUrl":
		for _, f := range MSTeamsExplicitWebhookUrlRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MSTeamsPluginCreate":
		for _, f := range MSTeamsPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MSTeamsURLResponse":
		for _, f := range MSTeamsURLResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MatchCustomMacros":
		for _, f := range MatchCustomMacrosRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MatchEventConsoleAlertsResponse":
		for _, f := range MatchEventConsoleAlertsResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "Metric":
		for _, f := range MetricRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MgmntTypeCaseParams":
		for _, f := range MgmntTypeCaseParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MgmntTypeIncidentParams":
		for _, f := range MgmntTypeIncidentParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MkEventDPluginCreate":
		for _, f := range MkEventDPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MoveFolder":
		for _, f := range MoveFolderRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "MoveHost":
		for _, f := range MoveHostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "NetworkScan":
		for _, f := range NetworkScanRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "NotificationBulking":
		for _, f := range NotificationBulkingRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "NotificationBulkingCheckbox":
		for _, f := range NotificationBulkingCheckboxRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "NotificationBulkingCommonAttributes":
		for _, f := range NotificationBulkingCommonAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "NotificationRuleRequest":
		for _, f := range NotificationRuleRequestRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "NotificationRuleResponse":
		for _, f := range NotificationRuleResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "NotificationRuleResponseCollection":
		for _, f := range NotificationRuleResponseCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ObjectActionMember":
		for _, f := range ObjectActionMemberRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ObjectCollectionMember":
		for _, f := range ObjectCollectionMemberRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ObjectProperty":
		for _, f := range ObjectPropertyRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "OpsGenieExplicitKey":
		for _, f := range OpsGenieExplicitKeyRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "OpsGeniePluginCreate":
		for _, f := range OpsGeniePluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "OpsGenieStoreID":
		for _, f := range OpsGenieStoreIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PagerDutyAPIKeyStoreID":
		for _, f := range PagerDutyAPIKeyStoreIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PagerDutyExplicitKey":
		for _, f := range PagerDutyExplicitKeyRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PagerDutyPluginCreate":
		for _, f := range PagerDutyPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "Parent":
		for _, f := range ParentRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PasswordCollection":
		for _, f := range PasswordCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PasswordObject":
		for _, f := range PasswordObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PendingChangesCollection":
		for _, f := range PendingChangesCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PluginBase":
		for _, f := range PluginBaseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PluginBase1":
		for _, f := range PluginBase1RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PluginName":
		for _, f := range PluginNameRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PluginWithParams":
		for _, f := range PluginWithParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ProxyAttributes":
		for _, f := range ProxyAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ProxyAttributes1":
		for _, f := range ProxyAttributes1RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ProxyTcp":
		for _, f := range ProxyTcpRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "PushOverPluginCreate":
		for _, f := range PushOverPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RegexpRewrites":
		for _, f := range RegexpRewritesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RegisterHost":
		for _, f := range RegisterHostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RenameHost":
		for _, f := range RenameHostRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RuleCollection":
		for _, f := range RuleCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RuleConditions":
		for _, f := range RuleConditionsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RuleExtensions":
		for _, f := range RuleExtensionsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RuleNotification":
		for _, f := range RuleNotificationRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RuleNotificationMethod":
		for _, f := range RuleNotificationMethodRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RuleObject":
		for _, f := range RuleObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RuleProperties":
		for _, f := range RulePropertiesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RulePropertiesAttributes":
		for _, f := range RulePropertiesAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RulesetCollection":
		for _, f := range RulesetCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RulesetExtensions":
		for _, f := range RulesetExtensionsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "RulesetObject":
		for _, f := range RulesetObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SMSAPIExplicitPassword":
		for _, f := range SMSAPIExplicitPasswordRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SMSAPIPStoreID":
		for _, f := range SMSAPIPStoreIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SMSAPIPluginCreate":
		for _, f := range SMSAPIPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SMSPluginBase":
		for _, f := range SMSPluginBaseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SNMPCommunity":
		for _, f := range SNMPCommunityRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SNMPv3AuthNoPrivacy":
		for _, f := range SNMPv3AuthNoPrivacyRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SNMPv3AuthPrivacy":
		for _, f := range SNMPv3AuthPrivacyRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SNMPv3NoAuthNoPrivacy":
		for _, f := range SNMPv3NoAuthNoPrivacyRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ServiceConditions":
		for _, f := range ServiceConditionsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ServiceEventType":
		for _, f := range ServiceEventTypeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ServiceGroup":
		for _, f := range ServiceGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ServiceGroupCollection":
		for _, f := range ServiceGroupCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ServiceGroupsRegex":
		for _, f := range ServiceGroupsRegexRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ServiceNowExplicitPassword":
		for _, f := range ServiceNowExplicitPasswordRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ServiceNowPasswordStoreID":
		for _, f := range ServiceNowPasswordStoreIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ServiceNowPluginCreate":
		for _, f := range ServiceNowPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SignL4TeamSecret":
		for _, f := range SignL4TeamSecretRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SignL4TeamSecretStoreID":
		for _, f := range SignL4TeamSecretStoreIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "Signl4PluginCreate":
		for _, f := range Signl4PluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SiteConfigAttributesCreate":
		for _, f := range SiteConfigAttributesCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SiteConfigAttributesUpdate":
		for _, f := range SiteConfigAttributesUpdateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SiteConnectionRequestCreate":
		for _, f := range SiteConnectionRequestCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SiteConnectionRequestUpdate":
		for _, f := range SiteConnectionRequestUpdateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SiteConnectionResponse":
		for _, f := range SiteConnectionResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SiteConnectionResponseCollection":
		for _, f := range SiteConnectionResponseCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SiteLoginRequest":
		for _, f := range SiteLoginRequestRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SlackPluginCreate":
		for _, f := range SlackPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SlackWebhookStore":
		for _, f := range SlackWebhookStoreRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SlackWebhookURL":
		for _, f := range SlackWebhookURLRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SocketAttributes1":
		for _, f := range SocketAttributes1RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SocketIP4":
		for _, f := range SocketIP4RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SocketIP6":
		for _, f := range SocketIP6RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SocketType":
		for _, f := range SocketTypeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SocketUnixAttributes":
		for _, f := range SocketUnixAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SpectrumPluginBase":
		for _, f := range SpectrumPluginBaseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SplunkStoreID":
		for _, f := range SplunkStoreIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SplunkURLExplicit":
		for _, f := range SplunkURLExplicitRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "StatusConnectionAttributes":
		for _, f := range StatusConnectionAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "StatusConnectionAttributes1":
		for _, f := range StatusConnectionAttributes1RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "StatusHostAttributes":
		for _, f := range StatusHostAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "StatusHostAttributesBase":
		for _, f := range StatusHostAttributesBaseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "StatusHostAttributesSet":
		for _, f := range StatusHostAttributesSetRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "SysLogToFromPriorities":
		for _, f := range SysLogToFromPrioritiesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "ThrottlePeriodicNotifications":
		for _, f := range ThrottlePeriodicNotificationsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "TimeAllowedRange":
		for _, f := range TimeAllowedRangeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "TimePeriodException":
		for _, f := range TimePeriodExceptionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "TimePeriodResponse":
		for _, f := range TimePeriodResponseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "TimePeriodResponseCollection":
		for _, f := range TimePeriodResponseCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "TimeRange":
		for _, f := range TimeRangeRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "TimeRange1":
		for _, f := range TimeRange1RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateAndAcknowledgeFilter":
		for _, f := range UpdateAndAcknowledgeFilterRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateAndAcknowledgeWithParams":
		for _, f := range UpdateAndAcknowledgeWithParamsRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateAndAcknowledgeWithQuery":
		for _, f := range UpdateAndAcknowledgeWithQueryRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateContactGroup":
		for _, f := range UpdateContactGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateDiscoveryPhase":
		for _, f := range UpdateDiscoveryPhaseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateFolderEntry":
		for _, f := range UpdateFolderEntryRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateGroup":
		for _, f := range UpdateGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateGroup1":
		for _, f := range UpdateGroup1RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateGroup2":
		for _, f := range UpdateGroup2RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateHostEntry":
		for _, f := range UpdateHostEntryRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateHostGroup":
		for _, f := range UpdateHostGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateNodes":
		for _, f := range UpdateNodesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UpdateServiceGroup":
		for _, f := range UpdateServiceGroupRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UseLiveStatusDaemon":
		for _, f := range UseLiveStatusDaemonRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserCollection":
		for _, f := range UserCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserContactOption":
		for _, f := range UserContactOptionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserIdleOption":
		for _, f := range UserIdleOptionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserObject":
		for _, f := range UserObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserRoleAttributes":
		for _, f := range UserRoleAttributesRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserRoleCollection":
		for _, f := range UserRoleCollectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserRoleObject":
		for _, f := range UserRoleObjectRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserSyncAttributes1":
		for _, f := range UserSyncAttributes1RequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserSyncBase":
		for _, f := range UserSyncBaseRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "UserSyncWithLdapConnection":
		for _, f := range UserSyncWithLdapConnectionRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "VictoropsPluginCreate":
		for _, f := range VictoropsPluginCreateRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "WhenToBulk":
		for _, f := range WhenToBulkRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "X509PEM":
		for _, f := range X509PEMRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	case "X509ReqPEMUUID":
		for _, f := range X509ReqPEMUUIDRequiredFieldNames {
			if f == fieldName {
				return true
			}
		}
	}
	return false
}

// IsDeprecatedField checks if a field is deprecated for a given schema.
func IsDeprecatedField(schemaName, fieldName string) bool {
	switch schemaName {
	}
	return false
}
